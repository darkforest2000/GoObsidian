Цель Go — сделать программирование приятным, избавив вас от особенностей C. Однако C остается языком программирования с очень большими возможностями и все еще полезен. Это означает, что существуют ситуации, например, при использовании базы данных или драйверов устройств, написанных на C, в которых все еще требуется использование C. Это говорит о том, что вам придется работать  
с C-кодом в Go-проектах.

# Вызов C-кода из Go в одном файле

Самый простой способ вызвать C-код из Go-программы— включить код на C в исходный Go-файл. Тут нужен особый подход, но это довольно быстро и не очень сложно. Рассмотрим исходный Go-файл с именем cGo.go. В этом файле содержится код на C и на Go, который мы разделим на три части.  Первая часть выглядит так:  
```go
package main  
// #include <stdio.h>  
// void callC() {  
// printf("Calling C code!\n");  
// }  
import "C"
```

	Как видим, C-код включен в Go-программу в виде комментариев. Однако благодаря импорту пакета C go tool знает, что делать с подобными  
	комментариями.

Таким образом, все остальные пакеты должны импортироваться отдельно.  В последней части cGo.go содержится следующий код:

```go
	fmt.Println("A Go statement!")  
	C.callC()  
	fmt.Println("Another Go statement!")  
}
```

Для того чтобы выполнить C-функцию callC(), ее нужно вызвать как C.callC().  Выполнение cGo.go приведет к следующим результатам:

```bash
$ go run cGo.go  
A Go statement!  
Calling C code!  
Another Go statement!
```

# Вызов из Go C-кода в отдельных файлах

Теперь попробуем вызывать C-код из Go-программы, если этот C-код находится в отдельном файле.  
Рассмотрим следующую задачу, которую мы решим с помощью нашей программы. Будем использовать две C-функции, которые мы якобы реализовали ранее и теперь не хотим или не можем переписать на Go.

## C-код

В этом подразделе представлен C-код нашего примера. Он содержится в двух  
файлах: callC.h и callC.c. Подключаемый файл (callC.h) хранит следующий код:  

```C
#ifndef CALLC_H  
#define CALLC_H  

void cHello();  
void printMessage(char* message); 

#endif  
```

Исходный C-файл (callC.c) содержит следующий C-код:  

```c
#include <stdio.h>  
#include "callC.h"  

void cHello() {  
printf("Hello from C!\n");  
}  
void printMessage(char* message) {  
printf("Go send me %s\n", message);  
}
```

Файлы callC.c и callC.h хранятся в отдельном каталоге, который в данном случае называется callClib. Но вы можете выбрать любое имя каталога по своему желанию.

```
В C-коде нет ничего, что бы указывало на то, что этот код будет вызываться из Go-программы. Главное — вызывать правильные C-функции  
с указанием верного количества параметров правильного типа. Посмо-  
трите на Go-код — и тогда все станет ясно.
```

## Go-код

В этом подразделе представлен исходный Go-код для нашего примера. Код нахо-  
дится в файле callC.go, и мы его рассмотрим по частям.  
Первая часть callC.go содержит следующий Go-код:  

```go
package main  
// #cgo CFLAGS: -I${SRCDIR}/callClib  
// #cgo LDFLAGS: ${SRCDIR}/callC.a  
// #include <stdlib.h>  
// #include <callC.h>  
import "C"
```

Самый важный оператор Go всего исходного Go-файла — это отдельный оператор import, используемый для подключения пакета C. Но C — это виртуальный Go-пакет, который просто дает инструкцию go build сначала обработать входной файл с помощью инструмента cgo, и только потом передать файл компилятору Go. Как видим, здесь тоже использованы комментарии, которые сообщают Go-программе о наличии в ней C-кода. В данном случае они указывают программе  
callC.go, где найти файл callC.h, а также файл библиотеки callC.a, который мы вскоре создадим. Такие строки начинаются с `#cgo`.  
Вторая часть программы выглядит так:

```go
import (  
	"fmt"  
	"unsafe"  
)  
func main() {  
	fmt.Println("Going to call a C function!")  
	C.cHello()   
	fmt.Println("Going to call another C function!")  
	myMessage := C.CString("This is Mihalis!")  
	defer C.free(unsafe.Pointer(myMessage))
	C.printMessage(myMessage)  
	fmt.Println("All perfectly done!")  
}
```

Чтобы передать строку из Go в C-функцию, нужно создать строку в формате C с помощью `C.CString()`. Кроме того, нам понадобится оператор defer, чтобы освободить память, занимаемую строкой C, после того как она будет использована. Оператор defer включает в себя вызов функции `C.free()` и затем `unsafe.Pointer()`. В следующем разделе вы узнаете, как скомпилировать и выполнить программу  
callC.go.

# Сочетание кода на Go и C

Теперь, когда у нас есть код на C и на Go, пора узнать, что нужно сделать, чтобы  выполнить файл на Go, из которого вызывается код на C.

Хорошая новость: нам не придется делать ничего сверхсложного, потому что  вся важная информация содержится в Go-файле. Единственное — нужно скомпилировать C-код, чтобы создать библиотеку, для чего следует выполнить такие  команды:

```bash
$ ls -l callClib/  
total 16  
-rw-r--r--@ 1 mtsouk staff 162 Jan 10 09:17 callC.c  
-rw-r--r--@ 1 mtsouk staff 89 Jan 10 09:17 callC.h  
$ gcc -c callClib/*.c  
$ ls -l callC.o  
-rw-r--r-- 1 mtsouk staff 952 Jan 22 22:03 callC.o  
$ file callC.o  
callC.o: Mach-O 64-bit object x86_64  
$ /usr/bin/ar rs callC.a *.o  
ar: creating archive callC.a  
$ ls -l callC.a  
-rw-r--r-- 1 mtsouk staff 4024 Jan 22 22:03 callC.a  
$ file callC.a  
callC.a: current ar archive  
$ rm callC.o
```

У нас появится файл с именем callC.a, расположенный в том же каталоге, что  и callC.go. Исполняемый файл gcc — это имя С-компилятора.  

Теперь мы готовы скомпилировать файл с Go-кодом и создать новый исполняемый файл:

```bash
$ go build callC.go  
$ ls -l callC  
-rwxr-xr-x 1 mtsouk staff 2403184 Jan 22 22:10 callC  
$ file callC  
callC: Mach-O 64-bit executable x86_64
```

Запустив исполняемый файл callC, получим следующий результат:

```
$ ./callC  
Going to call a C function!  
Hello from C!  
Going to call another C function!  
Go send me This is Mihalis!  
All perfectly done!
```

	Если вам нужно использовать небольшое количество C-кода, то весьма  
	желательно использовать общий Go-файл для кода на C и на Go — так  
	проще. Но если вы собираетесь сделать что-то большое и сложное,  
	лучше создать статическую C-библиотеку.

# Вызов Go-функций из C-кода

Аналогичным образом можно вызвать Go-функции из C-кода. В этом разделе представлен небольшой пример, в котором две Go-функции вызываются из C-программы. Для этого Go-пакет преобразуем в библиотеку C (shared library), которая будет использоваться в C-программе.

## Go-пакет

Представим код Go-пакета, который будет использоваться в C-программе. Именем Go-пакета должно быть main, но имя файла может быть любым; в данном случае  это ByC.go. Мы рассмотрим код пакета по частям

Первая часть кода Go-пакета выглядит так:  
```go
package main  

import "C" 

import (  
	"fmt"  
)  
```
Как вам известно, Go-пакет обязательно должен называться main. Нам также нужно импортировать в Go-код пакет C.

Вторая часть пакета содержит следующий Go-код:  
```go
// export PrintMessage  
func PrintMessage() {  
	fmt.Println("A Go function!")
```

Каждую функцию Go, которая будет вызываться из C-кода, необходимо сначала экспортировать. Это означает, что перед ее реализацией нужно поставить строку  комментария, начинающуюся с `//export`. После `//export` следует указать имя  функции, которую будет использовать C-код.  Последняя часть файла usedByC.go выглядит так:

```go
// export Multiply  
func Multiply(a, b int) int {  
	return a * b  
}  

func main() {  
}
```

Функция main() файла usedByC.go не нуждается в коде, поскольку она не будет  экспортироваться и, следовательно, не будет использоваться C-программой. Кроме того, поскольку мы хотим экспортировать функцию Multiply(), необходимо поставить перед реализацией этой функции строку `//export Multiply`. Теперь нужно сгенерировать из Go-кода общую библиотеку C, выполнив следующую команду:  

```bash
$ go build -o usedByC.o -buildmode=c-shared usedByC.go 
```

Эта команда создаст два файла с именами usedByC.h и usedByC.o: 

```bash
$ ls -l usedByC.*  
-rw-r--r--@ 1 mtsouk staff 204 Jan 10 09:17 usedByC.go  
-rw-r--r-- 1 mtsouk staff 1365 Jan 22 22:14 usedByC.h  
-rw-r--r-- 1 mtsouk staff 2329472 Jan 22 22:14 usedByC.o  
$ file usedByC.o  
usedByC.o: Mach-O 64-bit dynamically linked shared library x86_64  
```

После этого не следует вносить никаких изменений в usedByC.h.

## C-код

Соответствующий C-код содержится в исходном файле willUseGo.c, который мы  рассмотрим по частям. Первая часть willUseGo.c выглядит так:

```c
#include <stdio.h>  
#include "usedByC.h"  

int main(int argc, char **argv) {  
	GoInt x = 12;  
	GoInt y = 23;  
	printf("About to call a Go function!\n");  
	PrintMessage();  
}
```

Если вам знаком язык C, то вы поймете, зачем нужно подключить файлusedByC.h: именно благодаря этому файлу C-код узнает о доступных функциях библиотеки.  Вторая часть C-программы выглядит так:  

```go
	GoInt p = Multiply(x,y);  
	printf("Product: %d\n",(int)p);  
	printf("It worked!\n");  
	return 0;  
}  
```

Переменная GoInt p необходима для получения целочисленного значения из  функции Go; затем посредством операции (int) p это значение преобразуется  в целое число формата C.  
Компиляция и выполнение willUseGo.c на машине с macOS Mojave приведет к следующим результатам:

```bash
$ gcc -o willUseGo willUseGo.c ./usedByC.o  
$ ./willUseGo  
About to call a Go function!  
A Go function!  
Product: 276  
It worked!
```

[[Внутри Go]] [[Пакет unsafe]] [[Небезопасный код]]
