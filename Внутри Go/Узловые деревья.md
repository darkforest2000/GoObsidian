Узлы Go (nodes) — это объекты типа struct с большим количеством свойств. Подробнее об определении и использовании структур в Go вы узнаете из главы 4. Все  элементы Go-программы подвергаются синтаксическому разбору и анализируются модулями компилятора Go в соответствии с грамматикой языка. Конечным  результом анализа Go-кода являются соответствующее ему дерево. Дерево — это  альтернативный способ представления программы, предназначенный не для разработчика, а для компилятора.

	Обратите внимание, что команда go tool 6g -W test.go не будет работать  в новых версиях Go. Вместо нее следует использовать команду go tool  compile -W test.go.

В этом разделе мы сначала используем в качестве примера следующий Go-код,  который хранится в файле nodeTree.go. Это позволит нам увидеть информацию низкого уровня, предоставляемую go tool:  

```go
package main  

import (  
	"fmt"  
)  

func main() {  
	fmt.Println("Hello there!")  
}  
```
Go-код nodeTree.go довольно понятен, поэтому вы не удивитесь тому, что он  выводит следующие данные:  
```
$ go run nodeTree.go  
Hello there!
```

Теперь пора взглянуть на некоторые внутренние операции Go, для чего выполним следующую команду:

![[Pasted image 20221210214134.png]]

Как можно понять, компилятор Go и его инструменты делают многое незаметно для нас, даже в случае столь небольшой программы, как nodeTree.go.

	Параметр -W дает команде компиляции go tool инструкцию вывести на  экран дерево синтаксического анализа отладки (debug parse tree) после  проверки соответствия типов.

Посмотрим на результаты следующих двух команд:  

```bash
$ go tool compile -W nodeTree.go | grep before  
before walk main  
before walk init  
$ go tool compile -W nodeTree.go | grep after  
after walk main  
after walk init  
```

Как вы видите, ключевое слово before означает начало выполнения функции. Если бы у нашей программы было больше функций, то мы бы получили больше выходных данных, как показано в следующем примере:

```bash
$ go tool compile -W defer.go | grep before  
before d1  
before d2  
before d3  
before main  
before d2.func1  
before d3.func1  
before init  
before type..hash.[2]interface {}  
before type..eq.[2]interface {}
```

В этом примере использован Go-код из файла defer.go. Он намного сложнее,  чем nodeTree.go. Однако очевидно, что функция init() автоматически генерируется  Go, поскольку она существует в обоих результатах выполнения команды go tool  compile -W (для nodeTree.go и defer.go). Сейчас вы увидите более интересную  версию nodeTree.go с именем nodeTreeMore.go

```go
package main  

import (  
	"fmt"  
)  

func functionOne(x int) {  
	fmt.Println(x)  
}  

func main() {  
	varOne := 1  
	varTwo := 2  
	fmt.Println("Hello there!")  
	functionOne(varOne)  
	functionOne(varTwo)  
}
```

В программе nodeTreeMore.go определены две переменные с именами varOne и varTwo и дополнительная функция с именем functionOne. Поиск имен varOne, varTwo и functionOne в результатах выполнения команды go tool compile -W даст  нам следующее:

![[Pasted image 20221210214532.png]]

Как видим, переменная varOne представлена здесь как NAME-main.varOne,  varTwo — как NAME-main.varTwo, а функция functionOne() — как NAME-main.functionOne. Соответственно, функция main() здесь называется NAME-main.

Теперь рассмотрим следующий код дерева синтаксического анализа отладки  для программы nodeTreeMore.go:

![[Pasted image 20221210214705.png]]


Эти данные соответствуют определению функции functionOne(). Запись l(8) говорит о том, что определение этого узла находится в строке 8, то есть после  чтения строки 7. Целочисленная переменная NAME-main..autotmp_2 генерируется компилятором автоматически.

Рассмотрим следующий фрагмент данных дерева синтаксического анализа отладки:

![[Pasted image 20221210214819.png]]

Первая строка сообщает о том, что в строке 15 программы, на что указывает запись l(15), вызывается функция NAME-main.functionOne, которая, судя по записи l(7), определена в строке 7 программы. Запись FUNC-func(int) говорит о том, что эта функция принимает один целочисленный параметр. Список параметров функции, который указывается после CALLFUNC-list, включает в себя переменную  
NAME-main.varOne, которая, согласно записи l(12), определена в строке 12 программы.

# Хотите знать больше о go build?

Если вы хотите больше узнать о том, что происходит внутри компилятора, когда  выполняется команда go build, добавьте к ней флаг -x:

![[Pasted image 20221210214959.png]]
Повторю: очень многое из происходящего скрыто от нас, и хорошо бы об этом  помнить. Однако в большинстве случаев вам не придется иметь дело с детальными командами процесса компиляции.

[[Внутри Go]]




