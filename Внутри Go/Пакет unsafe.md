Программа moreUnsafe.go делает следующее: получает доступ ко всем элементам массива с помощью указателей.

Первая часть программы выглядит так:  

```go
package main  

import (  
	"fmt"  
	"unsafe"  
)  
```

Вторая часть moreUnsafe.go содержит следующий Go-код: 

```go
func main() {  
	array := [...]int{0, 1, -2, 3, 4}  
	pointer := &array[0]  
	fmt.Print(*pointer, " ")  
	memoryAddress :=uintptr(unsafe.Pointer(pointer)) + unsafe.Sizeof(array[0])  
	for i := 0; i < len(array)-1; i++ {  
		pointer = (*int)(unsafe.Pointer(memoryAddress))  
		fmt.Print(*pointer, " ")  
		memoryAddress = uintptr(unsafe.Pointer(pointer)) + unsafe.Sizeof(array[0])  
	}
```

Сначала переменная pointer указывает на адрес в памяти `array[0]` — первого элемента целочисленного массива. Затем переменная pointer, которая указывала на целочисленное значение, преобразуется в unsafe.Pointer(), потом — в uintptr.  Результат сохраняется в memoryAddress.

Значение `unsafe.Sizeof(array[0])` переводит нас к следующему элементу массива, а именно — сколько памяти занимает каждый элемент массива. Поэтому данное значение прибавляется к переменной memoryAddress на каждой итерации цикла for, что позволяет получить адрес в памяти следующего элемента массива.  

Запись `*pointer` разыменовывает указатель и возвращает сохраненное целочисленное значение.

Третья часть программы выглядит так:  
```go
	fmt.Println()  
	pointer = (*int)(unsafe.Pointer(memoryAddress))  
	fmt.Print("One more: ", *pointer, " ")  
	memoryAddress = uintptr(unsafe.Pointer(pointer)) + unsafe.Sizeof(array[0])  
	fmt.Println()  
}
```



В последней части программы мы пытаемся получить доступ к несуществующему элементу массива, используя указатели и адреса ячеек памяти. Вследствие использования пакета unsafe компилятор Go не может отследить эту логическую ошибку, в результате которой будет возвращено нечто некорректное.  При выполнении moreUnsafe.go генерируются следующие результаты:  

```go
$ go run moreUnsafe.go  
0 1 -2 3 4  
One more: 824634208008
```

Мы только что получили доступ ко всем элементам массива Go с помощью указателей. Однако настоящая проблема заключается в том, что при попытке доступа к недопустимому элементу массива программа, не генерируя ошибку, возвращает случайное число.

[[Внутри Go]]