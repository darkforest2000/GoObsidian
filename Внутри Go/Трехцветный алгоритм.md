В основе работы сборщика мусора Go лежит трехцветный алгоритм

Он может работать конкурентно, одновременно с программой, и использует барьер записи. Это означает, что при запуске Go-программы планировщик Go составляет график работы собственно приложения и сборщика мусора — как если бы планировщик Go имел дело с обычным приложением, состоящим из нескольких горутин!

Главный принцип алгоритма трехцветной пометки и очистки состоит в разделении объектов, находящихся в куче, на три набора, в соответствии с цветом, который назначается им алгоритмом. Объекты черного цвета гарантированно не имеют указателей ни на один  
объект белого цвета. Однако объект белого цвета может иметь указатель на объект черного цвета, поскольку это не влияет на работу сборщика мусора. Объекты серого цвета могут иметь указатели на некоторые объекты белого цвета. Именно объекты белого цвета являются претендентами на удаление.

Обратите внимание, что ни один объект не может перейти непосредственно из черного множества в белое — именно это обеспечивает работу алгоритма и позволяет освобождать память из-под объектов белого множества. Кроме того, ни один объект из черного множества не может напрямую указывать на объект из белого множества.

Итак, когда начинается сборка мусора, все объекты становятся белыми. Сборщик мусора перебирает все корневые объекты и окрашивает их в серый цвет.  

[Корневые объекты] — это объекты, к которым приложение может обращаться напрямую, включая глобальные переменные и другие элементы, находящиеся в стеке.  Большинство этих объектов зависят от Go-кода конкретной программы.

После этого сборщик мусора выбирает серый объект, помечает его черным и проверяет, есть ли у него указатели на другие объекты из белого множества. Это означает, что при проверке серого объекта на предмет указателей на другие объекты он окрашивается в черный цвет. Если проверка обнаружит, что у данного объекта есть один или несколько указателей на белые объекты, алгоритм поменяет цвет этих  
белых объектов на серый. Процесс продолжается до тех пор, пока не будут перебраны все объекты серого множества. Затем объекты белого множества считаются недостижимыми, и занимаемая ими память может использоваться повторно. Таким образом, считается, что в этот момент элементы белого множества попали в корзину

	Обратите внимание: если в какой-то момент сборки мусора объект из  
	серого множества станет недостижимым, он будет обработан не в этом, а в следующем цикле сборки мусора! Это не оптимальный, но и не такой уж плохой вариант.

Приложение, работающее во время выполнения сборки мусора, называется мутатором. 

[Мутатор] запускает небольшую функцию, называемую барьером за-  
писи. Эта функция выполняется всякий раз, когда изменяется указатель в куче. Если указатель объекта в куче изменился, это означает, что данный объект теперь достижим. Барьер записи помечает этот объект в серый цвет и помещает в серое множество.

	Мутатор отвечает за то, чтобы ни один элемент из черного множества  
	не имел указателя на элемент из белого множества. Это достигается  
	с помощью функции барьера записи. Невыполнение этого условия разрушило бы процесс сборки мусора и, скорее всего, привело бы к аварийному завершению работы программы.


В итоге кучу можно представить как граф, состоящий из связанных объектов.  Такой граф показан на рис. 2.1, где также продемонстрирован один из этапов  сборки мусора.

![[Pasted image 20221210191327.png]]

Итак, у нас есть три цвета: черный, белый и серый. Когда алгоритм начинает работу, все объекты окрашены в белый цвет. По мере работы алгоритма белые объекты перемещаются в одно из двух остальных множеств: серое или черное. Те объекты, которые останутся в белом множестве, в какой-то момент будут удалены.  

На представленном графе видно, что, хотя объект E, который относится к белому множеству, может получить доступ к объекту F, он сам недостижим из какого-либо другого объекта, потому что никакой другой объект не указывает на объект E. Это делает объект E идеальным претендентом для сборки мусора! Кроме того, объ-  
екты A, B и C являются корневыми объектами и всегда достижимы; следовательно, они не могут быть собраны как мусор.


Несложно понять, что алгоритм должен будет обработать оставшиеся элементы из серого множества и, следовательно, объекты A и F перейдут в черное множество: объект A — потому что  
является корневым элементом, а F — потому что не указывает ни на какой другой объект, пока так же будет находиться в сером множестве.  
После того как объект A будет удален сборщиком мусора, объект F станет недостижимым и попадет в мусор в следующем цикле сборщика мусора, поскольку недостижимый объект не может волшебным образом стать достижимым на следующей итерации цикла сборки мусора

Сборщик мусора Go может также применяться к таким переменным, как [[Каналы]]. Когда сборщик мусора обнаруживает, что канал недостижим, то есть недостижима переменная канала, сборщик мусора освобождает ресурсы этой переменной, даже если сам канал не закрыт.

[[Внутри Go]] [[Сборка мусора]]