_Срез_ (slice) — ключевая структура данных в Go. Это массив изменяемой длины, как _list_ в питоне или _Array_ в js. Обычно в программах на Go оперируют именно срезами, «чистые» массивы встречаются намного реже.

Срез определяется только типом элементов, но не их количеством. Чтобы создать срез ненулевой длины, используют встроенную функцию `make()`. Здесь мы создаем срез из трех пустых строк:

```go
s := make([]string, 3)
fmt.Printf("empty: %#v\n", s)
// empty: []string{"", "", ""}
```

Шаблон `%#v` возвращает «внутреннее представление» значения, примерно как _repr()_ в питоне.

С элементами среза можно работать точно так же, как с элементами массива:

```go
s[0] = "a"
s[1] = "b"
s[2] = "c"

fmt.Println("set:", s)
// set: [a b c]

fmt.Println("get:", s[2])
// get: c
```

`len()` возвращает длину среза:

```go
fmt.Println("len:", len(s))
// len: 3
```

Срез можно инициализировать при объявлении:

```go
s := []string{"a", "b", "c"}
fmt.Println("init:", s)
// init: [a b c]
```

В отличие от массива, в срез можно добавлять новые элементы через встроенную функцию `append()`. Функция возвращает новый срез:

```go
s := []string{"a", "b", "c"}

fmt.Println("src:", s)
// src: [a b c]

s = append(s, "d")
s = append(s, "e", "f")
fmt.Println("upd:", s)
// upd: [a b c d e f]
```

> Всегда используйте значение, которое возвращает `append()`. Вот так делать не стоит:
> 
```go
> append(s, "d")
> fmt.Println("upd:", s)
> ```
>  Дело в том, что срез сам по себе не хранит данные, это ссылка на конкретный массив. Если в массиве нет места для нового элемента, `append()` создаст новый массив побольше, скопирует в него старые элементы, добавит новый элемент и вернет ссылку на новый массив. Если эту ссылку проигнорировать, новый срез вы потеряете.

Срез можно скопировать через встроенную функцию `copy()`. Здесь создаем пустой срез `dst` такой же длины, как `s`, и копируем в него элементы `s`:

```go
src := []string{"a", "b", "c", "d", "e", "f"}
dst := make([]string, len(src))

copy(dst, src)
fmt.Println("copy:", dst)
// copy: [a b c d e f]
```

Срезы поддерживают... срезы (отсюда их название). Выражение `slice[from:to]` вернет срез от элемента с индексом `from` включительно до элемента с индексом `to` не включительно:

```go
s := []string{"a", "b", "c", "d", "e", "f"}

sl1 := s[2:5]
fmt.Println("sl1:", sl1)
// sl1: [c d e]
```

Этот срез включает все элементы, кроме `s[5]`:

```go
sl2 := s[:5]
fmt.Println("sl2:", sl2)
// sl2: [a b c d e]
```

А этот срез включает элементы от `s[2]` и до конца:

```go
sl3 := s[2:]
fmt.Println("sl3:", sl3)
// sl3: [c d e f]
```


### Срезы и строки

Строку можно преобразовать в срез байт и обратно:

```go
str := "го!"
```

```go
bytes := []byte(str)

fmt.Println(bytes)
// [208 179 208 190 33]

fmt.Println(str == string(bytes))
// true
```

Строку можно преобразовать в срез unicode-символов (Go называет их _рунами_). Одна руна может занимать несколько байт (что и произошло с рунами `г` и `о`):

```go
runes := []rune(str)

fmt.Println(runes)
// [1075 1086 33]

fmt.Println(str == string(runes))
// true
```

Объявлять срез можно так

```go
var abbr []rune
```

Так же можно искать количество одного элемента в строке 

```go
strings.Count("Cheese", "e") // 3
```

Слайс — это обёртка над указателем массива, и в Go слайс используется как структура следующего вида:

`len` — длина слайса, то есть количество доступных элементов в слайсе. 
`cap` — ёмкость базового массива, количество выделенной памяти для слайса

-   указатель на первый элемент базового массива — `ptr`;
-   длина слайса — `len`, количество элементов в слайсе;
-   ёмкость слайса — `cap`, количество элементов в массиве.

![image](https://pictures.s3.yandex.net:443/resources/basics_go_3.2_1654600417.png)

Параметры слайса `len` и `cap` могут быть получены с помощью вызова соответствующих встроенных функций `len()` и `cap()`. Прочитай о кап

### Изменение размеров слайса

Как вы уже знаете, слайс — последовательность элементов динамического размера.

Уменьшение размера слайса производится через операцию взятия слайса. Результат взятия можно присвоить этому же слайсу:

```go
    s := []int{1,2,3} // [1 2 3]
    s = s[:len(s)-1] // [1 2] 
```

Ёмкость массива при этом не изменяется.

Рассмотрим пример:

```go
    a := []int{1, 2, 3}
    fmt.Println(a, len(a), cap(a)) // [1 2 3] 3 3
    b := append(a, 4)
    fmt.Println(a, len(a), cap(a)) // [1 2 3] 3 3
    fmt.Println(b, len(b), cap(b)) // [1 2 3 4] 4 6 
```

После выполнения `append` значение `a` не изменилось, зато `b` увеличилось на один элемент, и его длина стала равна 4, а ёмкость 6.

Дело в механике `append`: если ёмкость слайса позволяет разместить добавляемые элементы — то есть разница между длиной слайса и его ёмкостью больше или равна количеству размещаемых элементов, — то `append` создаёт новый слайс, используя тот же базовый массив, а новые элементы записываются в него сразу после имеющихся элементов слайса.

Если же ёмкость слайса не позволяет разместить эти элементы, то создаётся новый базовый массив вдвое больше существующего, в него копируются все элементы переданного слайса и добавляются новые. Именно поэтому в нашем примере ёмкость слайса увеличилась с 3 до 6.

Чтобы соединить два слайса, нужно распаковать слайс `append(a,b...)`. Функция принимает некоторое количество отдельных элементов и преобразует слайс в список через распаковку.

Рассмотрим ещё несколько примеров.

```go
s := make([]int, 4, 7) // [0 0 0 0], len = 4 cap = 7
// 1. Создаём слайс s с базовым массивом на 7 элементов. 
// Четыре первых элемента будут доступны в слайсе.

slice1 := append(s[:2], 2, 3, 4)  
fmt.Println(s, slice1) // [0 0 2 3] [0 0 2 3 4]
// 2. Берём слайс из первых двух элементов s и добавляем к ним три элемента.
// Так как суммарная длина полученного слайса (len == 5) меньше ёмкости s[:2] (cap == 7), 
// то базовый массив остаётся прежним.
// Слайс s тоже изменился, но его длина осталась прежней

slice2 := append(s[1:2], 7) 
fmt.Println(s, slice1, slice2) // [0 0 7 3] [0 0 7 3 4] [0 7]
// 3. Здесь также базовый массив остаётся прежним, изменились все три слайса

slice3 := append(s, slice1[1:]...)
fmt.Println(len(slice3), cap(slice3))  // 8 14
// 4. Длина s и slice1[1:] равна 4, длина нового слайса будет равна 8,  
// что больше ёмкости базового массива.
// Будет создан новый базовый массив ёмкостью 14,
// ёмкость нового базового массива подбирается автоматически 
// и зависит от текущего размера и количества добавленных элементов

// 5. Легко проверить, что slice3 ссылается на новый базовый массив
s[1] = 99
fmt.Println(s, slice1, slice2, slice3) 
// [0 99 7 3] [0 99 7 3 4] [99 7] [0 0 7 3 0 7 3 4] 
```

Так этот процесс выглядит на картинке:

![[3.2.slices_1638795136.png]]

Здесь не очень понятно, будут ли новые слайсы ссылаться на тот же базовый массив или отправят свои копии в новый массив. Поэтому на практике функцию `append` рекомендуют лишь для присвоения слайса самому себе: `s = append(s, b)`.

	Чтобы использовать слайсы, нужно понимать механизм их работы. В противном случае вы будете получать ошибки, которые очень трудно найти. Старайтесь избегать ситуаций, когда на базовый массив ссылается несколько слайсов и происходит добавление или изменение элементов.

Операция взятия слайса поддерживает и третий параметр: `[low:high:max]` — третьим параметром указывается ёмкость базового массива, необходимая для создания нового слайса. При этом `max` должна быть меньше или равна ёмкости базового массива или слайса. Вряд ли вы встретите аналогичный пример на практике, но знать про него будет полезно.

## Присваивание слайса и передача в функции

Присвоение друг другу переменных слайса даже самого внушительного размера не потребляет больших вычислительных мощностей, потому что сама по себе структура слайса всегда содержит всего три поля: `ptr`, `len` и `cap`. Однако надо держать в уме, что эти переменные ссылаются на один и тот же массив, поэтому изменение в данных одного слайса может повлечь за собой изменение другого.

При передаче слайса в аргументы функции структура слайса копируется в локальную переменную внутри функции. Это позволяет изменить данные внутри слайса, переданного в функцию. Но если нужно добавить или удалить элементы из слайса, то эти изменения затронут только локальную переменную слайса.

Для примера возьмём пару функций из стандартной библиотеки:

```go
    s := []int{5, 4, 1, 3, 2}
    sort.Ints(s)
    fmt.Println(s) // [1 2 3 4 5] 
```

Функция `sort.Ints` сортирует полученный слайс целых чисел по возрастанию. Она не меняет размер и ёмкость слайса, поэтому может спокойно работать с ним.

```go 
    bSlice := []byte(" \t\n a lone gopher \n\t\r\n")
    fmt.Printf("%s", bytes.TrimSpace(bSlice)) // a lone gopher
    fmt.Printf("%s", bSlice)  // \t\n a lone gopher \n\t\r\n 
```

Функция `bytes.TrimSpace` принимает слайс байт и возвращает новый слайс байт, откуда были удалены начальные и конечные пробельные символы. Размер слайса должен измениться, а значит, `bSlice` останется нетронутым. В итоге `bytes.TrimSpace` подарит нам новый слайс.

## Копирование слайсов

Для копирования элементов из одного слайса в другой применяется функция `copy([]T dest, []T src)`, где `dest` — это слайс-приёмник, а `src` — слайс-источник. Эта функция только перезаписывает элементы, поэтому количество скопированных элементов будет равно меньшей длине из двух слайсов.

```go
var dest []int
dest2, dest3 := make([]int, 3),  make([]int, 5)
src := []int{1, 2, 3, 4}
copy(dest, src)
copy(dest2, src)
copy(dest3, src)
fmt.Println(dest, dest2, dest3, src ) // [] [1 2 3] [1 2 3 4 0] [1 2 3 4] 
```


```go
func RemoveDuplicates(input []string) []string {  
   distinctMap := make(map[string]int)  
   for _, v := range input {  
      distinctMap[v]++  
   }  
   var input2 []string  
   for _, v := range input {  
      input2 = append(input2, v) 
   }  
   return input2
```


[[Основы Go]] [[Функции для слайсов]]