В пакете `sync` есть специальный инструмент, который защищает общие данные и участки кода (такие участки называются _критической секцией_) от одновременного доступа. Этот инструмент — _мьютекс_ `[sync.Mutex](https://pkg.go.dev/sync#Mutex)`:

```go
func main() {
    rand.Seed(0)

    in := generate(100, 3)
    counter := map[string]int{}

    var wg sync.WaitGroup
    wg.Add(2)

    var lock sync.Mutex    // (1)
    go count(&wg, &lock, in, counter)
    go count(&wg, &lock, in, counter)

    wg.Wait()

    fmt.Println(counter)
}

// считает частоты слов
func count(wg *sync.WaitGroup, lock *sync.Mutex, in <-chan string, counter map[string]int) {
    defer wg.Done()
    for word := range in {
        lock.Lock()       // (2)
        counter[word]++
        lock.Unlock()     // (3)
    }
}
```

Мьютекс гарантирует, что участок кода между `Lock()` и `Unlock()` выполняется только одной горутиной в каждый момент времени. Работает это так:

1.  В ➊ мы создаем мьютекс и передаем его обеим горутинам `count()`.
2.  В ➋ первая горутина «запирает» мьютекс, после чего выполняет `counter[word]++`.
3.  Если в этот момент вторая горутина дойдет до ➋, то она заблокируется, потому что мьютекс «заперт».
4.  В ➌ первая горутина «отпирает» мьютекс.
5.  Теперь вторая горутина разблокируется. Она, в свою очередь, запирает мьютекс и выполняет `counter[word]++`.

> В русскоязычной литературе принято переводить lock как «блокировать» и unlock как «разблокировать». Я буду переводить их как «запирать» и «отпирать», чтобы не было путаницы с блокированием и разблокированием горутин (в англоязычной литературе block и unblock).

Таким образом, `counter[word]++` не может выполняться несколькими горутинами одновременно. Теперь карта не пострадает:

```bash
$ go run -race counter.go
map[cec:1 ... nol:2 not:3 ... tut:1]
```

Мьютекс используют в следующих ситуациях:

-   Если несколько горутин модифицируют одни и те же данные.
-   Если одна горутина модифицирует данные, а несколько читают.

Если все горутины только читают данные, мьютекс не нужен.

В отличие от некоторых других языков, мьютекс в Go не реентерабельный (non-reentrant). Если горутина вызовет `Lock()` на ей же запертом мьютексе — она заблокируется:

```go
func main() {
    var lock sync.Mutex

    lock.Lock()
    // ok

    lock.Lock()
    // fatal error: all goroutines are asleep - deadlock!
}
```

Это осложняет жизнь любителям использовать мьютексы в рекурсивных функциях (что в любом случае так себе идея).

Как и группа ожидания, мьютекс обладает внутренним состоянием, поэтому передавать его следует только по ссылке.

[песочница](https://go.dev/play/p/fLQaY9U8m99)

[[Горутины]] [[Гонки Горутины]] [[Одновременная модификация Горутины]] [[Мьютекс для чтения и записи Горутины]]