Представим время как числовую ось из прошлого в будущее, общую для всего мира.

```no-highlight
――――――――――――――――――•――――――――――――――――――――――> t
прошлое           сейчас           будущее
```

Одна и та же точка на этой оси соответствует разному локальному времени, в зависимости от географического положения. Например, если 24 мая в Нью-Йорке 9:00, то:

-   в Лондоне в это же время 14:00,
-   в Париже 15:00,
-   в Москве 16:00.

_Часовой пояс_ (timezone) описывает смещение локального времени относительно нулевой точки отсчета — всемирного координированного времени (UTC). При этом некоторые города живут в фиксированном часовом поясе (Москва, UTC+3), а некоторые летом живут по одному времени, зимой по другому (Париж, летом UTC+2, зимой UTC+1).

В любом случае, чтобы корректно сравнивать время из разных точек Земли, приходится учитывать, к какой локации относится это время. В Go за локации отвечает тип `time.Location`.

Проще всего считать время по UTC — для него предусмотрена готовая локация `time.UTC`:

```go
t1 := time.Date(2022, 5, 24, 0, 0, 0, 0, time.UTC)
```

`time.FixedZone()` создает часовой пояс с фиксированным смещением в секундах относительно UTC:

```go
utc := time.FixedZone("UTC", 0)
t1 := time.Date(2022, 5, 24, 0, 0, 0, 0, time.UTC)
t2 := time.Date(2022, 5, 24, 0, 0, 0, 0, utc)
fmt.Println(t1.Equal(t2))
// true
```

Обратите внимание — для проверки времени на равенство мы используем метод `Equal()` вместо `==`. Он понимает, что `time.UTC` и `time.FixedZone("UTC", 0)` дают одинаковое смещение, и возвращает `true`. Сравнение через `==` показало бы `false`. 

Еще пример:

```go
offset_sec := 3 * 3600
utc_3 := time.FixedZone("UTC+3", offset_sec)

// я в Москве, так что time.Local = UTC+3
t1 := time.Date(2022, 5, 24, 0, 0, 0, 0, time.Local)
t2 := time.Date(2022, 5, 24, 0, 0, 0, 0, utc_3)
fmt.Println(t1.Equal(t2))
// true
```

Часовой пояс можно получить по наименованию через `time.LoadLocation()`. Такая локация корректно учитывает переход на летнее время и другие особенности поведения времени в конкретной географической зоне:

```go
paris, _ := time.LoadLocation("Europe/Paris")
utc_2 := time.FixedZone("UTC+2", 2*3600)

t1 := time.Date(2022, 5, 24, 0, 0, 0, 0, paris)
t2 := time.Date(2022, 5, 24, 0, 0, 0, 0, utc_2)
fmt.Println(t1.Equal(t2))
// true
```

Чтобы перевести время из одного часового пояса в другой, используют метод `In()`:

```go
t := time.Date(2022, 5, 24, 0, 0, 0, 0, time.UTC)
fmt.Println(t)
// 2022-05-24 00:00:00 +0000 UTC

paris, _ := time.LoadLocation("Europe/Paris")
fmt.Println(t.In(paris))
// 2022-05-24 02:00:00 +0200 CEST

ny, _ := time.LoadLocation("America/New_York")
fmt.Println(t.In(ny))
// 2022-05-23 20:00:00 -0400 EDT
```

Список локаций можно посмотреть в [IANA Time Zone Database](https://en.wikipedia.org/wiki/Tz_database).

Локальное время — сложная штука. Поэтому старайтесь избегать часовых поясов и работать только с `time.UTC`.

[песочница](https://go.dev/play/p/io2zXNUjMtO)


### Сравнение

Как мы уже выяснили, для проверки дат на равенство используют метод `Equal()`:

```go
t1 := time.Date(2022, 5, 24, 17, 45, 22, 0, time.UTC)
t2 := time.Date(2022, 5, 24, 20, 45, 22, 0, time.FixedZone("UTC+3", 3*60*60))
fmt.Println(t1 == t2)
// false
fmt.Println(t1.Equal(t2))
// true
```

За сравнение «раньше» и «позже» отвечают методы `Before()` и `After()`:

```go
t1 := time.Date(2022, 5, 25, 0, 0, 0, 0, time.UTC)
t2 := time.Date(2022, 5, 25, 17, 45, 22, 0, time.UTC)
fmt.Println(t2.After(t1))
// true
fmt.Println(t1.Before(t2))
// true
```

Нулевое значение `time.Time` — 01.01.0001 00:00:00 UTC. Его проверяют через метод `IsZero()`:

```go
var t time.Time
fmt.Println(t)
// 0001-01-01 00:00:00 +0000 UTC
fmt.Println(t.IsZero())
// true
```

[песочница](https://go.dev/play/p/tDbrhnjdg5m)

[[Дата и время]]