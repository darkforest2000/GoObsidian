async/await — это распространенная в разных языках программирования концепция, при которой функции бывают двух видов: синхронные (выполняются последовательно) и асинхронные (могут выполняться одновременно). Асинхронные функции обязательно маркируют словом `async`. Чтобы дождаться результатов выполнения асинхронной функции, используют слово `await`. Если бы Go поддерживал эту концепцию, выглядело бы это как-то так:

```go
async func answer() int {
    time.Sleep(100 * time.Millisecond)
    return 42
}

n := await answer()
```

К счастью, никаких async/await в Go нет. Надеюсь, вы по ним не соскучились. Но если что, реализовать можно в пять строчек кода:

```go
// await executes fn concurrently
// and waits for results
func await(fn func() any) any {
    done := make(chan any, 1)    // (1)
    go func() {
        done <- fn()             // (2)
    }()
    return <-done
}

func main() {
    slowpoke := func() any {
        fmt.Print("I'm so... ")
        time.Sleep(500 * time.Millisecond)
        fmt.Println("slow")
        return "okay"
    }

    result := await(slowpoke)
    fmt.Println(result.(string))
}
```

> Если забыли: тип `any` — это синоним пустого интерфейса `interface{}`. То есть `await()` принимает функцию, которая возвращает одно значение, а какого оно типа — неважно. Ответственность за приведение типа лежит на клиенте.

Как видите, ничего особенного `await()` не делает:

-   создает канал завершения;
-   запускает горутину, в которой выполняет переданную функцию;
-   дожидается завершения;
-   возвращает результат клиенту.

Благодаря буферизованному каналу ➊, горутина в точке ➋ не блокируется, а сразу завершает работу. Таким образом, она перестает зависеть от вызывающей стороны. Конкретно в этой задаче можно обойтись и обычным каналом, ведь `await()` сразу начитывает результат. Но если такой гарантии нет — канал с буфером будет полезен.

[[Горутины]] [[Каналы]]