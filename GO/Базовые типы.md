
## Целые числа

Для представления целочисленных переменных в Go есть ряд типов, различающихся лишь размерностью и отсутствием или наличием знака в них:

-   знаковые: `int`, `int8`, `int16`, `int32`, `int64`;
-   беззнаковые: `uint`, `uint8`, `uint16`, `uint32`, `uint64`.

Если размерности `int64` недостаточно, можно воспользоваться типом `big.Int` из пакета `math/big`.

## Числа с плавающей точкой

Числа с плавающей точкой представлены в двух вариантах: комплексные и вещественные. Как и у целочисленных типов, у них есть разные размерности:

-   комплексные: `complex64`, `complex128`;
-   вещественные: `float32`, `float64`.

Двукратную разницу в размерности легко объяснить: переменные типа `complex` состоят из двух компонентов типа `float`.

Для числовых типов доступны следующие арифметические операции:

-   `+` — сложение,
-   `-` — вычитание,
-   `*` — умножение,
-   `/` — деление нацело,
-   `%` — остаток от деления.

Как и в языке С, для этих операций предусмотрена конструкция сокращения `a = a + b` до `a += b`:

```go
var a int 
a = 5
a *= 2 // 'a = a * 2'; 10 
```

Также доступны операции инкремента и декремента — сокращения `a = a + 1` и `a = a - 1` соответственно. В отличие, например, от С++, в Go реализованы только постфиксные версии этих операций.

Пример:

```go
var a int
a = 5
a++ // 'a = a + 1'; 6
a-- // 'a = a - 1';
```

## Булевы значения

Для работы с логическими выражениями в Go представлен базовый тип `bool`, который принимает значения `true` и `false`:

```go
var a bool
a = true
a = false // присвоить 0 или 1 нельзя!
```

Go — строго типизированный язык. Несмотря на то что под капотом предопределённая константа `false` имеет значение `0`, переменной типа `bool` можно присваивать только значения такого же типа, а не любой `0`. В таком случае код выдаст ошибку компиляции из-за несоответствия типов.

## Строки

В Go существует встроенный тип `string` для представления текстовых данных:

```go
var a string
a = "Hello, world!" 
```

Строки в Go представляют собой массив из значений типа `byte`. По этой причине к элементам строки можно обращаться по индексу, а к самим строкам применима встроенная функция `len`, которая возвращает её длину в байтах:

```go
var a string
a = "abc"
println(len(a)) // 3 
```

Строка хранится как массив байт, но он неизменяемый:

```go
var a string
a = "abc"
println(a[2]) // выведет значение второго байта 99
// строки в Go неизменяемы, нельзя написать a[2] = 10
a[2] = 10 // здесь будет ошибка 
```

В данном случае длина строки в байтах равна количеству элементов, но это не всегда так. Дело в том, что Go из коробки поддерживает Unicode, а значит, строки могут содержать символы, не входящие в таблицу ASCII и не умещающиеся в один байт:

```go
var a string
a = "абц"
println(len(a)) // 6 
```

По этой же причине обращение по индексу иногда может возвращать неожидаемое значение:

```go
var a string
a = "абц"
println(a[5]) // 134 
```

Для работы с Unicode в Go предусмотрен встроенный тип `rune`, способный вместить больше одного байта — любой символ таблицы Unicode. Например, с помощью него можно получить корректное количество символов из предыдущего примера:

```go
import "unicode/utf8"
//...
var a string
a = "абц"
println(utf8.RuneCountInString(a)) // 3 
```

Строковые значения в Go можно представить ещё одним способом. Если заключить строковое значение в обратные апострофы ` `` `, а не двойные кавычки `""`, форматирование строки будет автоматически преобразовано в управляющие символы:

```go
var stringFormattedVar string
// следующие выражения равнозначны 
stringFormattedVar = "Hello,\nworld!\n\n\t\t\"quote!\""
stringFormattedVar = `Hello,
world!

        "quote!"` 
```

[[Пользовательские типы]]