_Карта_ (map), так же известная как словарь (dict), хеш-таблица (hash table) или ассоциативный массив (associative array) — это неупорядоченный набор пар «ключ-значение».

Чтобы создать пустую карту, используют `make()`:

```go
m := make(map[string]int)
```

Задать пары «ключ-значение»:

```go
m["key"] = 7
m["other"] = 13
```

Вывести содержимое карты:

```go
fmt.Println("map:", m)
// map: map[key:7 other:13]
```

Получить значение по ключу:

```go
val := m["key"]
fmt.Println("val:", val)
// val: 7
```

`len()` возвращает количество записей (пар «ключ-значение») в карте:

```go
fmt.Println("len:", len(m))
// len: 2
```

`delete()` удаляет запись по ключу:

```go
delete(m, "other")
fmt.Println("map:", m)
// map: map[key:7]
```

Обращение к записи по ключу возвращает необязательное второе значение: признак, есть такой ключ в карте или нет. Обращение по несуществующему ключу не приведет к ошибке, но вернет этот признак со значением `false`:

```go
_, ok := m["other"]
fmt.Println("has other:", ok)
// has other: false
```

Пустой идентификатор `_` указывает, что нам не интересно само значение по ключу, важен только признак «есть/нет» (`ok`).

Карту можно инициализировать при объявлении:

```go
n := map[string]int{"foo": 1, "bar": 2}
fmt.Println("map:", n)
// map: map[bar:2 foo:1]
```

Так же можно задать тип интерфейс, что позволит задавать разные типы для ключей и значений

```go
func main() {
  ldict := map[interface{}]interface{} {
    1: "English",
    "ru": 123,
    "fr": "French",
  }
  fmt.Println(ldict)
}
// map[1:English fr:French ru:123]
```

Так же можно сравнивать мапы (2 способа)

```go
firMap := make(map[string]int, 3)
secMap := make(map[string]int, 3)
fmt.Println(reflect.DeepEqual(firMap, secMap)) // I способ
// true
fmt.Sprint(map1) == fmt.Sprint(map2) // II способ
// true
```


## Ограничения для типов ключей

Для ключей должны быть определены операторы `==` и `!=`, поэтому ключ не может быть функцией, хеш-таблицей или слайсом.

Если вы попробуете сделать так,

```go
var MyMap map[[]byte]string 
```

то получите ошибку компиляции:

```
./prog.go:6:12: invalid map key type []byte 
```

На тип значений не накладывается никаких ограничений.

## Обработка ненайденых значений

Если сделать `m := make(map[int]int)`, не заполнить данными и всё же запросить значение ключа 100 `v := m[100]`, запрос будет отработан и вернёт значение `0` (нулевое значение для типа `int`).

Если присвоить значение ключу 50 `m[50] = 0` и запросить его `v := m[50]`, ответ будет таким же — `0`.

Это два разных случая:

-   ключу не назначено значение;
-   ключу назначено нулевое значение.

Чтобы различать их, лучше пользоваться полной формой индексного выражения: `v, ok = m[k]`. Тогда переменная `ok` примет значение `true`, если ключ найден, и `false` в противном случае.


Взять ссылку на элемент `map` [не получится](https://golang.org/ref/spec#Address_operators).

Такой код

```go
addr := &m[k] 
```

вызовет ошибку компиляции:

```
cannot take the address of m[k] 
```

Функция `len()` не даёт гарантии, что `map` инициализирована. Чтобы удостовериться, избежав run-time panic, можно сравнить таблицу с `nil` — нулевым значением для типа `map`. И `nil` — единственное значение, с которым можно сравнивать `map`. Сравнивать `map` друг с другом нельзя, так как оператор `==` не определён.

```go
var m map[string]string
if m != nil {            // если не проверить это условие,
    m["foo"] = "bar"    // то здесь можно получить panic
} 
```

Функция `delete(m, k)` удаляет из таблицы `m` элемент с ключом `k`. Если таблица не инициализирована или такого ключа в ней нет, run-time panic не будет, просто no-op.

```go
m := map[int]string{1: "first"}
v, ok := m[1]
fmt.Println(v, ok)
delete(m, 1)
v, ok = m[1]
fmt.Println(v, ok) 
```

Выведет:

```
first true
 false 
```

Пустая структура `struct{}` вообще не занимает память.

```go
m := map[int]struct{}
```

[[Основы Go]]