_Указатель_ (pointer) содержит адрес памяти, который ссылается на конкретное значение.

Тип `*T` — указатель на значение типа `T`. Если указатель не инициализирован, он равен `nil` (аналог _None_ в питоне и _null_ в js).

```go
// iptr - указатель на значение типа int
// пока что он пустой
var iptr *int
fmt.Println(iptr)
// <nil>
```

Оператор `&` возвращает указатель на конкретное значение:

```go
i := 42
iptr = &i

// теперь iptr ссылается на i
fmt.Println(iptr)
// 0xc000118000
```

`0xc000118000` — адрес памяти. По этому адресу находится значение `42`.

Оператор `*` обращается к значению, на которое ссылается указатель. Оно доступно как для чтения, так и для записи:

```go
// прочитать значение i через указатель iptr
fmt.Println(*iptr)
// 42

// установить значение i через указатель iptr
*iptr = 21
fmt.Println(i)
// 21
```

Вот схема непростых отношений между значением и указателем на него:

```no-highlight
  &i                 i
┌──────────────┐   ┌──────────┐
│ 0xc000118000 │ → │ 42       │
└──────────────┘   └──────────┘
  *int               int
```

`&i` — указатель на `i`. Его тип — `*int`, а значение — 0xc00011800. По адресу 0xc000118000 находится значение `i` — 42.

```no-highlight
  iptr = &i          *iptr
┌──────────────┐   ┌──────────┐
│ 0xc000118000 │ → │ 42       │
└──────────────┘   └──────────┘
```

`iptr` — указатель на `i`. Вызывая `*iptr`, мы обращаемся по адресу 0xc000118000 и получаем значение `i` — 42.

Остаток урока мы посвятим указателям. Если они вам «не зашли», можно перейти к следующему уроку и вернуться сюда, когда будет подходящий настрой.

### Указатели в параметрах функции

Указатели в параметрах функции позволяют изменять переданные значения. Вот как это работает.

Функция `addval()` принимает параметр типа `int` — конкретное число. При вызове Go передает не оригинальное число `n`, а его копию — `nval`:

```go
func addval(nval int, delta int) {
    nval += delta
}

n := 42
addval(n, 3)
fmt.Println(n)
// 42
```

`addval()` модифицировала копию оригинального числа `nval`, так что само `n` не изменилось.

Функция `addptr()` принимает параметр типа `*int` — указатель на число. При вызове Go передает адрес в памяти, по которому находится оригинальное число `n` — указатель `nptr`. Функция изменяет значение `n` по указателю через оператор `*`:

```go
func addptr(nptr *int, delta int) {
    *nptr += delta
}

n := 42
addptr(&n, 3)
fmt.Println(n)
// 45
```

Благодаря оператору `&`, в функцию передано не значение `n`, а указатель на него. `addptr()` изменила оригинальное значение `n` через переданный указатель.

### Указатель или значение?

Базовый принцип такой:

-   Если функция только читает переменную, но не изменяет — передавайте значение.
-   Если функция изменяет значение — передавайте указатель.

Функция `math.Max()` возвращает максимальное из двух чисел:

```go
a := 5
b := 3
max := math.Max(a, b)
```

`a` и `b` не изменяются, поэтому функция принимает обычные значения.

Функция `fmt.Scanf()` считывает значения из стандартного ввода и записывает их в переданные переменные. Поэтому принимает указатели:

```go
var a, b int
fmt.Scanf("%d-%d", &a, &b)
```

Правило работает для скалярных значений (логических, чисел, строк) и массивов. Со срезами и картами другая история.

### Указатель или значение? [[Срезы]] и [[Карты]]

Функция стандартной библиотеки `sort.Ints()` сортирует срез:

```go
func Ints(nums []int)
```

Обратите внимание — функция ничего не возвращает, она изменяет элементы оригинального среза. Но почему тогда `nums` передан как значение (`[]int`), а не как указатель (`*[]int`)?

Дело в том, что срез сам по себе не содержит данные массива. Срез — это легковесная структура данных, одно из полей которой — указатель на конкретный массив. Поэтому `nums` внутри функции — это копия, но не всего массива, а этой легковесной структуры с указателем на массив. Обращаясь к элементу среза, функция переходит по указателю и модифицирует оригинальный элемент массива.

```no-highlight
  slice             array
┌──────────────┐   ┌─┬─┬───┬─┐
│ 0xc000118000 │ → │0│1│...│n│
└──────────────┘   └─┴─┴───┴─┘
```

Если функция изменяет отдельные элементы среза, передавайте его как значение:

```go
func sortSlice(nums []int) {
    sort.Ints(nums)
}

nums := []int{5, 1, 3, 9}
sortSlice(nums)
fmt.Println(nums)
// [1 3 5 9]
```

Этот подход не сработает, если изменить сам срез (добавить или удалить элементы):

```go
func appendByVal(nums []int, n int) {
    nums = append(nums, n)
}

nums := []int{42}
appendByVal(nums, 43)
fmt.Println(nums)
// ожидание: [42 43]
// реальность: [42] 
```

`nums` внутри функции — это копия оригинального среза. Изменив `nums` через `append()`, функция поменяла копию, а оригинал не изменился.

Чтобы изменить срез в целом, можно использовать указатель:

```go
func appendByPtr(nums *[]int, n int) {
    *nums = append(*nums, n)
}

nums := []int{42}
appendByPtr(&nums, 43)
fmt.Println(nums)
// [42 43]
```

Но в обычных функциях такой подход нечасто встретишь. Лучше вернуть новый срез, чем переопределять старый по указателю:

```go
func appendAndReturn(nums []int, n int) []int {
    nums = append(nums, n)
    return nums
}

nums := []int{42}
nums = appendAndReturn(nums, 43)
fmt.Println(nums)
// [42 43]
```

Итого:

-   если функция не меняет срез — передавать значение;
-   если функция меняет отдельные элементы, но не сам срез — передавать значение;
-   если функция меняет сам срез — передавать значение и возвращать новое значение.

Вариант «передавать указатель на срез» остается для _методов_, о которых мы поговорим на следующем уроке.

Для карт принцип такой же.

С константами сложнее — у них забрать адрес не получится.

```go
  const c = 5
  p1 := &"abc" // ошибка компиляции
  p2 := &с // ошибка компиляции 
```

Тип переменной, на которую создаётся указатель, должен соответствовать типу указателя.

```go
  var p *int
  var a int = 5
  var b string = "abc"
  p = &a 
  p = &b // ошибка компиляции 
```

Литералы композитных типов создают в памяти переменную соответствующего типа, поэтому указатель можно создать вот так:

```go
  type A struct {
      IntField int
  }
  // Литерал А{} создаёт в памяти переменную типа А. Затем от неё берётся указатель
  p := &A{ 
      IntField: 10,
  } 
```

А ещё в Go есть встроенная функция `new()`. В качестве параметра ей передаётся тип, а возвращается указатель на новую переменную соответствующего типа.

```go
    type A struct {
        IntField int
    }
    
    p := new(A) //  то же самое, что и &A{} 
```

Указатели ведут себя так же, как и обычные переменные. Их можно копировать, присваивая другим переменным тип указателя, передавать и возвращать в функции, а также создавать указатели уже на них.

Тип указателя на указатель описывается как `**T`, например `**int`.

Чтобы получить или изменить значение, хранящееся по указателю, применяют оператор **разыменования** (**dereference**) `*`.

```go
i := 42
p := &i
fmt.Println(*p) // читаем значение переменной i через указатель p (42)
*p = 21         // записываем в переменную i значение 21 через указатель p 
```

Вызов оператора разыменования на `nil`-указателе приведёт к панике на этапе исполнения кода, и программа откажется работать дальше.

```go
var p *int
fmt.Println(*p) // panic: runtime error: invalid memory address or nil pointer derefe
```

## Указатели и [[Структуры]]

Для указателей на структуры в Go есть возможность неявного разыменования при доступе к полям структуры.

```go
type A struct {
    IntField int
}

p := &A{}
p.IntField = 42 // вместо (*p).IntField = 42 
```

## Сравнение указателей

Для указателей определены операторы сравнения (`==`, `!=`). Два указателя равны, если они указывают на один и тот же объект в памяти либо если оба равны `nil`.

### Когда стоит использовать указатели

-   Когда нужно изменить значение переменной из вызываемой функции. Если передать переменную по значению, все модификации внутри функции применятся к локальной копии и оставят исходную переменную неизменной.
    

```go
  incrementCopy := func(i int) {
      i++
  }

  increment := func(i *int) {
      (*i)++
  }

  i := 42

  incrementCopy(i)
  fmt.Println(i) // 42

  increment(&i)
  fmt.Println(i) // 43
   
```

Когда нужно подчеркнуть, что значение может отсутствовать. Например, есть функция, которая возвращает запись о пользователе `type User struct{...}` по его идентификатору. Результат-указатель даёт понять, что не по всем идентификаторам может быть найден пользователь. Пример функции с такой сигнатурой:

```go
  func FindUser(id UserID) *User
   
```

-   Когда вы работаете с ресурсами вроде файловых дескрипторов или сокетов. Копирование таких переменных может быть связано с исчерпанием системных ресурсов или вообще не производиться.
-   Когда вы работаете с большими переменными и на копирование по стеку затрачивается больше ресурсов, чем на сборку мусора от указателей.


### Когда не стоит использовать указатели

-   Когда хочется ускорить приложение и кажется, что копирование структур — слишком дорогая операция. До тех пор, пока нет тестов, однозначно показывающих, что указатели повышают производительность, лучше не пытаться оптимизировать. Вероятнее всего, напрасно потратите силы или снизите производительность системы, увеличив расходы на сборку мусора.
-   Задумываться о замене передачи по значению на передачу по указателю стоит, когда размер структуры достигает порядка сотен байт.
-   Когда множество указателей в памяти сильно нагружают сборщик мусора. Такое может произойти, к примеру, при создании собственной in-memory базы данных.


## Пример работы с указателями

Представим некоторую структуру, которая описывает пользователя:

```go 
type Person struct {
  Name string
  Age int
  lastVisited time.Time
}  
```

Почти как в sql

```SQL
CREATE TAVLE Person(
  Name text,
  Age int,
  lastVisited timestamp,
)  
```

В поле `LastVisited` нужно сохранять дату последнего посещения. Напрямую сделать это нельзя, ведь поле неэкспортируемое. Без указателей функция выглядела бы примерно так:

```go
func GetPersonWithLastVisited(p Person) Person {
    return Person{
        Name:        p.Name,
        Age:         p.Age,
        lastVisited: time.Now(), // time.Now() возвращает текущее время
    }
}

p := Person{
  Name: "Alex",
  Age: 25,
  lastVisited: time.Time{}, // пустое значение времени — пользователь ещё не посещал наш сервис
}

p = GetPersonWithLastVisited(p) 
```

У такого подхода много недостатков. Структура сначала копируется в функцию, потом создаётся новая структура, в неё копируются поля старой, а затем результат должен быть скопирован в старую структуру. Кроме того, изменения в структуре потребуют изменений в коде функции, даже если логически её это не касается.

C указателями всё становится проще:

```go
func UpdatePersonWithLastVisited (p *Person )  {
  p.lastVisited = time.Now() 
} 

p := Person{
  Name: "Alex",
  Age: 25,
  lastVisited: time.Time{},
}

UpdatePersonWithLastVisited(&p) 
```

Здесь в функцию был передан указатель на переменную, что позволило изменить её поле без лишнего копирования. Такая функция работает быстрее, а код становится проще.





[[Основы GO]] 