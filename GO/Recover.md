Раз есть непредвиденные ошибки (паника), должен быть и способ их поймать. В Go для этого используется встроенная функция `recover()`. Посмотрим, как она работает.

Мы все так же забыли проверить, что индекс попадает в границы:

```go
func getChar(str string, idx int) byte {
    return str[idx]
}
```

Но зная свою забывчивость, решили отловить любые непредвиденные ошибки:

```go
func protect(fn func()) {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println("ERROR:", err)
        } else {
            fmt.Println("Everything went smoothly!")
        }
    }()
    fn()
}
```

`protect()` первым делом объявляет анонимную отложенную функцию, которая сработает после того, как будет выполнена `fn()`. Если срабатывает паника, вызывается отложенная функция. Внутри нее `recover()` возвращает ошибку, которая вызвала панику. Если паники не было, отложенная функция тоже вызывается, но `recover()` внутри возвращает `nil`.

Здесь сработает паника:

```go
protect(func() {
    c := getChar("hello", 10)
    fmt.Println("hello[10] = ", c)
})
// ERROR: runtime error: index out of range [10] with length 5
```

А здесь функция отработает без ошибок:

```go
protect(func() {
    c := getChar("hello", 4)
    fmt.Println("hello[4] =", c)
})
// hello[4] = 111
// Everything went smoothly!
```

Возможно, вы заметили, что ручной вызов `panic()` в сочетании с `defer()` и `recover()` можно использовать, чтобы эмулировать конструкцию try-catch. В Go так не принято. Всегда старайтесь явно возвращать ошибки из функции, а на вызывающей стороне проверять их.

[[Panic]] [[Собственный тип ошибки]] [[Ошибки]]