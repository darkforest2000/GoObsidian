## Константы

**Константа** — это типизированное значение, которое вычисляется на этапе компиляции и известно компилятору. В отличие от переменной, значение константы не может быть изменено во время работы программы. Вы уже сталкивались с константами ранее — это строковые, булевы и числовые литералы.

```go
var i int = 5 // здесь 5 — безымянная целочисленная константа
s := "Hello " // здесь "Hello" — строковая константа, значением которой
              // инициализирована переменная s 
```

Если в коде постоянно используется какое-то число или строка, можно присвоить это значение переменной, но тогда оно не будет защищено от случайного изменения. Для решения этой проблемы Go даёт возможность давать константам имена.

![image](https://pictures.s3.yandex.net:443/resources/1.3.constants_1653914348.png)

## Именованные константы

Ключевое слово `const` определяет именованную константу, при этом константе можно присвоить результат некоторого выражения. В одном объявлении `const` можно определить несколько констант.

Именованные константы можно инициализировать выражениями, состоящими из констант или литералов следующих типов:

-   числа;
-   строки;
-   символы (руны);
-   булевы значения.

```go
const pi = 3.14159
const doublePi = pi * 2
const version = "1.0.0"

// эквивалентно

const (
   pi = 3.14159
   doublePi = pi * 2
   version = "1.0.0"
)

func main() {
    fmt.Println(version, pi, doublePi)
} 
```

Результат:

```
1.0.0 3.14159 6.28318 
```

Именованные константы позволяют изменять значение только в одном месте кода. Например, в приведённом примере легко увеличить точность числа пи или изменить номер версии.

## Нетипизированные константы

Именованные константы могут быть разного типа. Тип связан с хранимым значением:

```go
const intConst = 5 
const floatConst = 5.0
const runeConst = 'A'
const strConst = "Hello, world!"
const boolConst = true 
```

Может показаться, что если опустить тип при объявлении константы, то компилятор выберет его сам — как в случае с короткой формой объявления переменных. Это так лишь отчасти. В случае с константами отсутствие явного указания типа имеет большее значение.

Например, если вы объявляете константу `intConst` и присваиваете ей значение `5`, то получаете **целочисленную константу с неопределённым типом** (`untyped int`). Конкретный тип значения этой константы ещё не определён и в разных контекстах будет интерпретироваться компилятором по-разному. Это позволяет ослабить типизацию для констант, не отказываясь от сильной типизации глобально.

Благодаря этому подходу будет работать следующий пример:

```go
package main

import (
    "fmt"
)

const id = 100

func main() {
    var i int64 = id
    var f float64 = id

    fmt.Println("i=", i, "f=", f)
} 
```

Программа выведет:

```go
i = 100 f = 100 
```

Если определить `id` как переменную `var id = 100`, то возникнут ошибки компиляции при определении переменных `i` и `f`:

```go
./prog.go:10:16: cannot use id (variable of type int) as type int64 in variable declaration
./prog.go:11:18: cannot use id (variable of type int) as type float64 in variable declaration 
```

Если бы константы, как и переменные в Go, всегда имели конкретный тип, то работать с ними было бы сложнее. Более того, Go позволяет смешивать числовые литералы разных типов (`untyped int`, `untyped float`), поэтому корректно следующее выражение:

```go
var a float64
a = 5 + 5.0 
```

Константы, как и переменные, можно группировать.

```go
const Program = "Моя программа"
const Version = "1.0.0"

// эквивалентно

const (
   Program = "Моя программа"
   Version = "1.0.0"
) 
```

Если в группе у константы не указано значение, то оно равно значению предыдущей константы.

```go
const (
    pi = 3.1415
    e
    name = "John Doe"
    fullName
)

func main() {
    fmt.Println("pi =", pi, "e =", e)
    fmt.Println("name =", name, "fullName =", fullName)
} 
```

Результатом работы программы будет:

```go
pi = 3.1415 e = 3.1415
name = John Doe fullName = John Doe 
```

## Типизированные константы

Если при объявлении вы указываете тип константы явным образом, она становится **типизированной** и подчиняется правилам сильной типизации Go. В этом случае вы работаете с константой как с неизменяемой переменной:

```go
const flag uint8 = 128

func main() {
    var i int = flag
    fmt.Println(i)
} 
```

При компиляции этого примера возникнет ошибка `cannot use flag (constant 128 of type uint8) as type int in variable declaration`, так как у константы `flag` тип `uint8`, а у переменной `i` тип `int`.

## Ключевое слово iota

Что, если в коде нужно реализовать **перечисление (enum)**? В Go для этого нет встроенной синтаксической конструкции или специального типа. Однако можно просто объявить ряд констант и работать с ними:

```go
const (
    Black = "black"
    Gray = "gray"
    White = "white"
)

func main() {
    fmt.Println(Black != Gray) // true
} 
```

Зачастую в перечислении важна прежде всего возможность различить два элемента. Значения же этих элементов (в данном случае констант) играют второстепенную роль. Это значит, что необязательно использовать строковые константы — вполне подойдут целочисленные:

```go
const (
    Black = 0
    Gray = 1
    White = 2
)

func main() {
    fmt.Println(Black != Gray) // тоже true
} 
```

При таком перечислении вручную есть вероятность получить неожиданное поведение — например, если по ошибке присвоить двум константам в перечислении одинаковое целочисленное значение:

```go
const (
    Black = 0
    Gray = 0
)

func main() {
    fmt.Println(Black != Gray) // false
} 
```

К тому же при таком подходе не очень удобно объявлять длинные перечисления.

Для удобного объявления и инициализации блоков констант в Go есть автоматический инкремент `iota`. При объявлении каждого блока `const` значение `iota` равно 0 и увеличивается на 1 для каждого следующего элемента:

```go
const (
    Black = iota
    Gray
    White
)

// счётчик обнуляется
const (
    Yellow = iota
    Red
    Green = iota // это присваивание не обнулит iota
    Blue
)

func main() {
    fmt.Println(Black, Gray, White) 
    fmt.Println(Yellow, Red, Green, Blue)
} 
```

Программа выведет:

```
0 1 2
0 1 2 3 
```

Данную конструкцию применяют не только для перечислений. Ключевое слово `iota` можно также использовать в арифметических выражениях, чтобы быстро объявить ряд значений с прогрессией. Следует помнить, что `iota` увеличивается на единицу для каждой строки, где указано имя константы, даже если той было присвоено конкретное значение.

```go
const (
    _ = iota*10  // обратите внимание, что можно пропускать константы 
    ten
    hundred
    thousand
)

const (
    hello = "Hello, world!"  // iota равна 0
    one = 1                  // iota равна 1

    black = iota   // iota равна 2
    gray
)

func main() {
    fmt.Println(ten, hundred, thousand)
    fmt.Println(black, gray)
} 
```

Программа выведет:

```go
10 20 30
2 3 
```

## Пользовательские типы в константах

Предположим, нужно определить константы для дней недели.

```go
const (
    Monday = iota + 1
    Tuesday
    //...
    Sunday
) 
```

Если перечислить их так, то все константы будут иметь нетипизированный числовой тип и могут использоваться в любых выражениях, что может вносить путаницу: `var i int = Monday + 1`. В подобных случаях стоит определить пользовательский тип и указать его при определении констант.

```go
type Weekday int

const (
    Monday Weekday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

func NextDay(day Weekday) Weekday {
    return (day % 7) + 1
}

func main() {
    var today Weekday = Sunday
    tomorrow := NextDay(today)
    fmt.Println("today =", today, "tomorrow =", tomorrow)
} 
```

Программа выведет:

```go
today = 7 tomorrow = 1 
```

## Литералы

В Go можно использовать различные представления строковых и числовых литералов. Проиллюстрируем на примере целого числа `1000`:

```go
1000
1000.0
1_000 // можно разделять части числа символом '_' для удобства восприятия
01750 // восьмеричное представление, начинается с 0
0x3e8 // шестнадцатеричное представление
0b001111101000 // бинарное представление 
```

Любой из этих литералов может быть использован в выражениях и даст одно и то же значение.

[[Базовые типы]]