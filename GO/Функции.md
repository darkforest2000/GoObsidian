_Функция_ — центральная конструкция языка. Вот несколько примеров.

Эта функция принимает два целых числа и возвращает их сумму:

```go
func sum(a int, b int) int {
    return a + b
}
```

Результат возвращается явно, через `return`.

Если у нескольких идущих подряд параметров один и тот же тип, их можно «схлопнуть» и указать тип только для последнего:

```go
func sum(a, b, c int) int {
    return a + b + c
}
```

Функция может возвращать несколько значений. В этом примере — частное и остаток от деления одного числа на другое:

```go
func divide(divisible, divisor int) (int, int) {
    quotient := divisible / divisor
    remainder := divisible % divisor
    return quotient, remainder
}
```

Результат вызова можно сразу разложить по переменным:

```go
q, r := divide(10, 3)
fmt.Println("10 / 3 =", q)
// 10 / 3 = 3
fmt.Println("10 % 3 =", r)
// 10 % 3 = 1
```

Или проигнорировать одно из значений с помощью пустого идентификатора `_`:

```go
_, r = divide(42, 2)
if r == 0 {
    fmt.Println("42 is divisible by 2")
}
// 42 is divisible by 2
```

### Вариативные функции

Функция может принимать произвольное количество аргументов в «хвосте» (как _*args_ в питоне или _...args_ в js). Например, так ведет себя `fmt.Println()`. В Go такие функции называют _вариативными_ (variadic).

Эта функция суммирует целые числа:

```go
func sum(nums ...int) {
    fmt.Print(nums, " -> ")
    total := 0
    for _, num := range nums {
        total += num
    }
    fmt.Println(total)
}
```

Можно передавать индивидуальные аргументы, как у обычной функции:

```go
sum(1, 2)
// [1 2] -> 3
sum(1, 2, 3)
// [1 2 3] -> 6
```

А можно передать срез, преобразовав его в список аргументов с помощью `...`:

```go
nums := []int{1, 2, 3, 4}
sum(nums...)
// [1 2 3 4] -> 10
```


[[Основы GO]] [[Анонимные функции]]