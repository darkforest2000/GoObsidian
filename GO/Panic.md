Также в Go существует механизм **паники** ([panic]). Если конструкция выше — типичный способ проверить выполнение той или иной функции, то паника выбрасывается только тогда, когда исполняющий код попадает в нестандартную ситуацию, которую невозможно обработать. Одна из самых частых причин паники — разыменовывание `nil`-указателя или выход за пределы массива. По умолчанию паника будет идти вверх по стеку и завершать все функции, пока не завершит функцию `main`, а вместе с ней и весь процесс.

Однако её можно поймать и обработать, используя конструкцию `defer` и встроенную функцию `recover`.

`defer` — это ещё одна необычная концепция языка, которая позволяет отложенно выполнять блоки кода: например, чтобы закрывать файлы по завершении работы с ними.

Можно рассматривать `defer` как замену деструкторов/менеджеров контекста в других языках (`try_with_resources` из Java, `with` из Python).

```go
func foo() {
    // паникуем
    panic("unexpected!")
}
//...
    // выполняется после срабатывания паники
    defer func() {
        if r := recover(); r != nil {
            // обработка паники, в переменной r будет лежать строка "unexpected!"
        }
    }()
    // внутри foo срабатывает паника
    foo()
```

Может показаться, что паника очень похожа на механизм исключений, но это не так. Выбрасывая `exception`, функция обычно ожидает, что исключение будет поймано выше обработчиком исключений `try — catch`. Однако перехват паники происходит не всегда. Код, который спровоцировал панику, обычно не ждёт, что она будет обработана, и процесс вполне может завершиться.

![[0.2.exception_panic_1636547152.png]]

Связка функций `panic` и `recover` напоминает механизм исключений `try — catch` в других языках. Но если стандартная работа с ошибками не требует дополнительных ресурсов, то вызов `panic` приводит к раскручиванию стека, а это затратная операция.

Несмотря на то что функция `recover` позволяет продолжить выполнение программы, её следует применять лишь в оправданных ситуациях. Например, стандартный веб-сервер использует `recover`, чтобы паника в одном обработчике не завершила весь процесс.

Также стоит помнить о возможных утечках памяти и неопределённых значений глобальных переменных после выхода из аварийной ситуации, что может привести к новым конфликтам. Существуют ситуации, когда паника не может быть отловлена, и программа однозначно завершается. Это, например, ситуации, связанные с конкурентностью или тем, что на компьютере закончилась память.

[[Основы Go]] [[Собственный тип ошибки]] [[Ошибки]] [[Recover]] [[Обертывание собственных ошибок]]