Также в Go существует механизм **паники** ([panic]). Если конструкция выше — типичный способ проверить выполнение той или иной функции, то паника выбрасывается только тогда, когда исполняющий код попадает в нестандартную ситуацию, которую невозможно обработать. Одна из самых частых причин паники — разыменовывание `nil`-указателя или выход за пределы массива. По умолчанию паника будет идти вверх по стеку и завершать все функции, пока не завершит функцию `main`, а вместе с ней и весь процесс.

Однако её можно поймать и обработать, используя конструкцию `defer` и встроенную функцию `recover`.

`defer` — это ещё одна необычная концепция языка, которая позволяет отложенно выполнять блоки кода: например, чтобы закрывать файлы по завершении работы с ними.

Можно рассматривать `defer` как замену деструкторов/менеджеров контекста в других языках (`try_with_resources` из Java, `with` из Python).

```go
func foo() {
    // паникуем
    panic("unexpected!")
}
//...
    // выполняется после срабатывания паники
    defer func() {
        if r := recover(); r != nil {
            // обработка паники, в переменной r будет лежать строка "unexpected!"
        }
    }()
    // внутри foo срабатывает паника
    foo()
```

Может показаться, что паника очень похожа на механизм исключений, но это не так. Выбрасывая `exception`, функция обычно ожидает, что исключение будет поймано выше обработчиком исключений `try — catch`. Однако перехват паники происходит не всегда. Код, который спровоцировал панику, обычно не ждёт, что она будет обработана, и процесс вполне может завершиться.

![[0.2.exception_panic_1636547152.png]]

[[Основы Go]]