Бывает, что несколько независимых функций отправляют результаты каждая в свой канал. А работать при этом удобнее с общим каналом результатов. Тогда приходится объединять выходные каналы функций в итоговый канал.

Функция `rangeGen()` отправляет в канал числа в указанном диапазоне:

```go
func rangeGen(start, stop int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := start; i < stop; i++ {
            time.Sleep(50 * time.Millisecond)
            out <- i
        }
    }()
    return out
}
```

> Для простоты изложения на этом и дальнейших шагах будем работать с неотменяемыми горутинами. Как превратить любую неотменяемую горутину в отменяемую — вы уже знаете.

Запускаем ее дважды, объединяем выходные каналы и печатаем результаты:

```go
func main() {
    in1 := rangeGen(11, 15)
    in2 := rangeGen(21, 25)

    start := time.Now()
    merged := merge(in1, in2)
    for val := range merged {
        fmt.Print(val, " ")
    }
    fmt.Println()
    fmt.Println("Took", time.Since(start))
}
```

Осталось только реализовать функцию `merge()`.

Вот первое, что приходит в голову:

```go
func merge(in1, in2 <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for val := range in1 {
            out <- val
        }
        for val := range in2 {
            out <- val
        }
    }()
    return out
}
```

Последовательно проходим по первому каналу, затем второму, и отправляем результаты в объединенный канал:

```bash
11 12 13 14 21 22 23 24
Took 350ms
```

Но такая реализация уничтожила многозадачность. Пока `merge()` начитывает результаты от первой горутины `rangeGen()`, вторая горутина `rangeGen()` заблокирована — никто не готов читать ее выходной канал. Поэтому выполнение и заняло 350 мс вместо ожидаемых 200 мс (8 значений * 50 мс / 2 горутины = 200 мс).

Нужно что-то другое.

Чтобы независимо начитывать из входных каналов, запустим две горутины:

```go
func merge(in1, in2 <-chan int) <-chan int {
    var wg sync.WaitGroup
    wg.Add(2)

    out := make(chan int)

    // первая горутина начитывает из in1 в out
    go func() {
        defer wg.Done()
        for val := range in1 {
            out <- val
        }
    }()

    // вторая горутина начитывает из in2 в out
    go func() {
        defer wg.Done()
        for val := range in2 {
            out <- val
        }
    }()

    // ждем, пока исчерпаются оба входных канала,
    // после чего закрываем выходной
    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}
```

Проверяем:

```bash
11 21 12 22 23 13 14 24 
Took 200ms
```

Другое дело.

Можно обойтись и одной горутиной, сохранив быстродействие. Поможет инструкция `select`. Вспомним ее полезное свойство:

> Если незаблокированных веток несколько, выбирает одну из них случайным образом и выполняет ее.

Таким образом, если селектить одной веткой из `in1`, а второй из `in2` — объединение должно работать почти с такой же скоростью, как две независимые горутины:

```go
func merge(in1, in2 <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for {
            select {
            case out <- <-in1:
            case out <- <-in2:
            }
        }
    }()
    return out
}
```

Однако, на практике это выглядит примерно так:

```bash
21 11 12 22 13 23 24 14 0 0 0 0 0 0 0 0 0 0... далее до бесконечности
```

Такая реализация продолжает выбирает значения из входных каналов даже после того, как они закрыты — до бесконечности.

Для корректной работы не хватает трех условий:

-   выбирать значения из `in1`, только если он открыт;
-   выбирать значения из `in2`, только если он открыт;
-   если `in1` и `in2` оба закрыты — выйти из цикла.

`select` может справиться и с этим. Поможет свойство nil-каналов, о котором мы говорили на прошлом уроке:

> Чтение из nil-канала навсегда блокирует горутину.

Если превратить `in1` в `nil` после того, как он закрылся — `select` перестанет из него читать (он ведь игнорирует заблокированные ветки). Аналогично для `in2`:

```go
func merge(in1, in2 <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for in1 != nil || in2 != nil {
            select {
            case val1, ok := <-in1:
                if ok {
                    out <- val1
                } else {
                    in1 = nil
                }

            case val2, ok := <-in2:
                if ok {
                    out <- val2
                } else {
                    in2 = nil
                }
            }
        }
    }()
    return out
}
```

Теперь каждая ветка `select` отключается после того, как соответствующий канал закрыт. А когда закрыты оба канала — прекращается цикл `for`. Проверим:

```bash
21 11 22 12 23 13 24 14 
Took 200ms
```

Работает!

P.S. Помните, я говорил, что nil-каналы бывают полезны в некоторых специфических случаях? Вот это один из них.

[песочница](https://go.dev/play/p/CfTplvTQynk)

[[Каналы]] [[Горутины]]