_Конвейер_ (pipeline) — это последовательность операций, каждая из которых принимает на входе данные, обрабатывает их определенным образом и отдает на выход. Входом и выходом для каждой операции выступает канал.

Собственно, последние три урока мы только тем и занимаемся, что строим конвейеры. Но давайте еще разок закрепим для верности.

Типичный конвейер выглядит так:

-   читатель (начитывает исходные данные из файла, базы или по сети);
-   N обработчиков (преобразуют данные, фильтруют, агрегируют, дополняют информацией из внешних источников);
-   писатель (записывает результат обработки в файл, базу или по сети).

Этапов конвейера с обработчиками может быть сколько угодно: сначала фильтруем, затем преобразуем, наконец агрегируем. На каждом этапе может запускаться несколько одновременных обработчиков, а вот читатель и писатель обычно существуют в единственном экземпляре.

Рассмотрим конвейер из 5 этапов:

-   `rangeGen()` генерит числа в указанном диапазоне (читатель);
    
-   `takeLucky()` выбирает «счастливые» числа (обработчик);
    
-   `merge()` объединяет независимые каналы (обработчик);
    
-   `sum()` суммирует числа (обработчик);
    
-   `printTotal()` печатает результат (писатель).
    

```go
// количество и сумма счастливых чисел
type Total struct {
    count  int
    amount int
}

// генерит числа в указанном диапазоне
func rangeGen(start, stop int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := start; i < stop; i++ {
            out <- i
        }
    }()
    return out
}

// выбирает счастливые числа
func takeLucky(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for num := range in {
            if num%7 == 0 && num%13 != 0 {
                out <- num
            }
        }
    }()
    return out
}

// объединяет независимые каналы
func merge(channels []<-chan int) <-chan int {
    out := make(chan int)
    // ...
    return out
}

// суммирует числа
func sum(in <-chan int) <-chan Total {
    out := make(chan Total)
    go func() {
        defer close(out)
        total := Total{}
        for num := range in {
            total.amount += num
            total.count++
        }
        out <- total
    }()
    return out
}

// печатает результат
func printTotal(in <-chan Total) {
    total := <-in
    fmt.Printf("Total of %d lucky numbers = %d\n", total.count, total.amount)
}

func main() {
    readerChan := rangeGen(1, 1000)
    luckyChans := make([]<-chan int, 4)
    for i := 0; i < 4; i++ {
        luckyChans[i] = takeLucky(readerChan)
    }
    mergedChan := merge(luckyChans)
    totalChan := sum(mergedChan)
    printTotal(totalChan)
    // Total of 132 lucky numbers = 66066
}
```

Даже на такой игрушечной задаче конвейер удобнее, чем одна большая функция:

-   каждый этап решает ровно одну задачу — легче понять код;
-   можно удалять и добавлять отдельные этапы, не трогая остальную логику;
-   можно независимо менять степень параллелизма на каждом этапе;
-   можно переиспользовать этапы в других конвейерах.

Задачи вида «выгрузить, обработать и загрузить» постоянно встречаются на практике. Конвейеры отлично для них подходят.