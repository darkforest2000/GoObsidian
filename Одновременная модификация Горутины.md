До сих пор горутины у нас не лезли в дела друг друга. Чтобы обмениваться данными, они использовали каналы — это безопасно. Но что будет, если обращаться к «обычным» объектам из нескольких горутин? Проверим.

Напишем программу, которая считает частоту слов:

```go
func main() {
    rand.Seed(0)

    in := generate(100, 3)
    counter := map[string]int{}

    var wg sync.WaitGroup
    wg.Add(2)

    go count(&wg, in, counter)
    go count(&wg, in, counter)

    wg.Wait()

    fmt.Println(counter)
}

// считает частоты слов
func count(wg *sync.WaitGroup, in <-chan string, counter map[string]int) {
    defer wg.Done()
    for word := range in {
        counter[word]++
    }
}

// генерит слова и отправляет их в канал
func generate(nWords, wordLen int) <-chan string {
    // ..
}
```

`generate()` генерит слова и отправляет их в канал `in`. `main()` создает пустую карту `counter` и передает ее двум горутинам `count()`. `count()` читает из канала `in` и заполняет карту частотами слов. В результате в `counter` для каждого слова должна быть его частота.

Запустим:

```no-highlight
$ go run counter.go
map[cec:1 ... nol:2 not:3 ... tut:1]
```

И еще раз, на всякий случай: 

```no-highlight
$ go run counter.go
fatal error: concurrent map writes
```

Ошибка.

Go не нравится одновременный доступ к карте из нескольких горутин. На первый взгляд, это странно. Вот единственная операция, которую горутина `count()` выполняет с картой:

```go
counter[word]++
```

Выглядит как атомарное действие. Почему бы не выполнять его из нескольких горутин?

Проблема в том, что действие только выглядит атомарным. Операция «увеличить значение в карте по ключу» состоит из цепочки более мелких действий. Если часть этих действий выполнит одна горутина, а часть другая — целостность карты будет нарушена. О чем Go нам и сообщает.

[песочница](https://go.dev/play/p/1EJ4BEKURv1)

[[Горутины]] [[Гонки Горутины]]