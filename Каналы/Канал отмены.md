Есть функция, которая отправляет в канал числа в указанном диапазоне:

```go
func rangeGen(start, stop int) <-chan int {
    out := make(chan int)
    go func() {
        for i := start; i < stop; i++ {
            out <- i
        }
        close(out)
    }()
    return out
}
```

Работает вроде бы корректно:

```go
func main() {
    generated := rangeGen(41, 46)
    for val := range generated {
        fmt.Println(val)
    }
}
```

```bash
$ go run rangegen.go 
41
42
43
44
45
```

Проверим, что будет, если завершить цикл досрочно:

```go
func main() {
    generated := rangeGen(41, 46)
    for val := range generated {
        fmt.Println(val)
        if val == 42 {
            break
        }
    }
}
```

```bash
41
42
```

На первый взгляд, по-прежнему корректно. Но не совсем — горутина `rangeGen()` зависла:

```go
func rangeGen(start, stop int) <-chan int {
    out := make(chan int)
    go func() {
        for i := start; i < stop; i++ {    // (1)
            out <- i                       // (2)
        }
        close(out)
    }()
    return out
}
```

Поскольку `main()` вышла из цикла на числе 42, то цикл ➊ внутри `rangeGen()` тоже не завершился. Он навсегда заблокировался на строчке ➋ при попытке отправить число 43 в канал `out`. Горутина зависла. Канал `out` тоже не закрылся, так что если бы от него зависели другие горутины — зависли бы и они.

В данном случае большой беды в этом нет: когда `main()` завершится, среда выполнения завершит и все прочие горутины. Но если бы `main()` продолжала работать, и снова и снова вызывала `rangeGen()` — зависшие горутины бы накапливались. Это плохо: горутины хоть и легковесные, но не совсем «бесплатные». Рано или поздно память может закончиться (сборщик мусора горутины не собирает).

Получается, нужна возможность досрочно завершить горутину.

[песочница](https://go.dev/play/p/NQ8McjDpfAz)

### Канал отмены

Для начала создадим отдельный _канал отмены_ (cancel channel), через который `main()` будет сигнализировать `rangeGen()`, что пора завершаться:

```go
func main() {
    cancel := make(chan struct{})    // (1)
    defer close(cancel)              // (2)

    generated := rangeGen(cancel, 41, 46)    // (3)
    for val := range generated {
        fmt.Println(val)
        if val == 42 {
            break
        }
    }
}
```

Мы создаем канал `cancel` ➊ и сразу настраиваем отложенный вызов `close(cancel)` ➋. Так часто делают, чтобы не отслеживать по коду все места, в которых нужно закрыть канал. `defer` гарантирует, что канал в любом случае закроется при выходе из функции, так что о нем можно не беспокоиться.

Затем передаем канал `cancel` в горутину ➌. Теперь, когда канал закроется, горутина должна как-то понять это и завершить работу. Хотелось бы добавить примерно такую проверку:

```go
func rangeGen(cancel <-chan struct{}, start, stop int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := start; i < stop; i++ {
            out <- i
            if <-cancel {    // (1)
                return
            }
        }
    }()
    return out
}
```

Если `cancel` закрыт, то проверка ➊ пройдет (закрытый канал всегда возвращает нулевое значение, помните?), и горутина завершит работу. Но вот беда: если `cancel` не закрыт, то горутина заблокируется и на следующую итерацию цикла не пойдет.

Нам нужна другая, неблокирующая логика:

-   если `cancel` закрыт, выйти из горутины;
-   иначе отправить очередное значение в `out`.

В Go для этого существует инструкция `select`:

```go
func rangeGen(cancel <-chan struct{}, start, stop int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := start; i < stop; i++ {
            select {
            case out <- i:    // (1)
            case <-cancel:    // (2)
                return
            }
        }
    }()
    return out
}
```

`select` отчасти похож на `switch`, только создан специально для работы с каналами. Вот что он делает:

1.  Проверяет, какие ветки (case) не заблокированы.
2.  Если таких веток несколько, выбирает одну из них случайным образом и выполняет ее.
3.  Если все ветки заблокированы, блокирует выполнение, пока хотя бы одна ветка не разблокируется.

В нашем случае, пока `cancel` открыт, его ветка ➋ заблокирована (невозможно прочитать значение из канала, если никто не готов в него записать). А вот ветка ➊ `out <- i` разблокирована, потому что `main()` начитывает значения из `out`. Соответственно, `select` на каждой итерации цикла будет выполнять `out <- i`.

Затем `main()` дойдет до числа 42 и прекратит начитывать из `out`. После этого обе ветки `select` заблокируются и горутина (временно) зависнет.

Наконец, в `main()` выполнится отложенный `close(cancel)`, после чего в `select` разблокируется ветка ➋, и горутина завершит работу. Попутно закроется канал `out` (благодаря `defer`).

Если `main()` передумает останавливаться на 42 и снова будет начитывать все значения, подход с cancel-каналом продолжит корректно работать:

```go
func main() {
    cancel := make(chan struct{})
    defer close(cancel)

    generated := rangeGen(cancel, 41, 46)
    for val := range generated {
        fmt.Println(val)
    }
}
```

Здесь `rangeGen()` завершится еще до того, как `main()` вызовет `close(cancel)`. Ну и ладно, проблем от этого никаких.

Таким образом, благодаря cancel-каналу и проверке через `select`, горутина `rangeGen()` корректно завершится вне зависимости от того, что происходит в `main()`. И никаких зависших горутин!

Канал завершения:

```go
// горутина b принимает канал,
// на котором позже сигнализирует,
// что закончила работу
func b(done chan<- struct{}) {
    // do work...
    done <- struct{}{}
}

func a() {
    done := make(chan struct{})
    go b(done)
    // горутина a ждет, пока b закончит работу
    <- done
}
```

Канал отмены:

```go
// горутина b принимает канал,
// на котором позже получит сигнал отмены
func b(cancel <-chan struct{}) {
    // do work...
    select {
    case <-cancel:
        return
    }
}

func a() {
    cancel := make(chan struct{})
    go b(cancel)
    // горутина a сигнализирует b,
    // что той пора заканчивать
    close(cancel)
}
```

На практике для обоих каналов — отмены и завершения — часто используют название `done`, так что не удивляйтесь. На курсе я буду использовать `cancel` для отмены и `done` для завершения, чтобы не возникало путаницы.