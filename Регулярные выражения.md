[Регулярные выражения](https://github.com/google/re2/wiki/Syntax) — это специальный язык для поиска и замены в тексте по шаблону. В Go за регулярные выражения отвечает пакет `regexp`.

Синтаксис «регулярок» в Go не такой богатый, как в Python или Java. Но зато гарантируется, что поиск отрабатывает за линейное время O(n) — этим другие языки обычно похвастать не могут.

#### Компиляция

Перед использованием шаблон регулярного выражения следует скомпилировать. Благодаря этому дальнейшие методы поиска и замены будут выполняться быстро, и не будут парсить каждый раз шаблон заново.

```go
// одна или более цифр
re := regexp.MustCompile(`\d+`)
```

Для шаблона обычно используют _сырые строки_ (raw strings) в `` `таких кавычках` `` вместо `"двойных кавычек"`, чтобы не экранировать в шаблоне обратный слеш `\` и сами кавычки `"`.

#### Поиск по шаблону

```go
// одна или более цифр
re := regexp.MustCompile(`\d+`)
s := "2050-11-05 is November 5th, 2050"

// подходит ли строка под шаблон?
ok := re.MatchString(s)
fmt.Println(ok)
// true

// первое совпадение с шаблоном
first := re.FindString(s)
fmt.Println(first)
// 2050

// индекс начала и окончания
// первого совпадения
idx := re.FindStringIndex(s)
fmt.Println(idx)
// [0 4]

// N совпадений с шаблоном (в данном случае 3)
// если указать -1 - вернет все совпадения
three := re.FindAllString(s, 3)
fmt.Println(three)
// [2050 11 05]

// индексы совпадений
indices := re.FindAllStringIndex(s, 3)
fmt.Println(indices)
// [[0 4] [5 7] [8 10]]
```

####  Группы

```go
// сам шаблон описывает дату в формате дддд-мм-гг
// а три группы соответствуют году, месяцу и дню
re := regexp.MustCompile(`(\d\d\d\d)-(\d\d)-(\d\d)`)
s := "2050-11-05 is November 5th, 2050"

// совпадение со всем шаблоном
match := re.FindString(s)
fmt.Println(match)
// 2050-11-05

// совпадения с группами шаблона
groups := re.FindStringSubmatch(s)
fmt.Println(groups)
// [2050-11-05 2050 11 05]

// индексы групп
indices := re.FindStringSubmatchIndex(s)
fmt.Println(indices)
// [0 10 0 4 5 7 8 10]
```

#### Разбивка на части

```go
// разделителем считаются цифры, окруженные пробелами
re := regexp.MustCompile(`\s*\d+\s*`)
s := "one 01 two 02 three 03"

parts := re.Split(s, -1)
fmt.Printf("%#v\n", parts)
// []string{"one", "two", "three", ""}
```

#### Замена

```go
re := regexp.MustCompile(`(\d\d\d\d)-(\d\d)-(\d\d)`)
src := "2050-11-05 is November 5th, 2050"

// замена по шаблону
res := re.ReplaceAllString(src, "$3.$2.$1")
fmt.Println(res)
// 05.11.2050 is November 5th, 2050

// замена функцией
fn := func(src string) string {
    parts := strings.Split(src, "-")
    reversed := []string{parts[2], parts[1], parts[0]}
    return strings.Join(reversed, ".")
}
res = re.ReplaceAllStringFunc(src, fn)
fmt.Println(res)
// 05.11.2050 is November 5th, 2050
```

### О регулярках

Программисты, знакомые с регулярными выражениями, часто начинают использовать их повсюду. Это не лучший путь:

-   сложные регулярки тяжело поддерживать;
-   регулярки медленные.

Вот две реализации функции `slugify()`. Первая без регулярных выражений, вторая с ними:

```go
func slugify(src string) string {
    // 1) привести строку к нижнему регистру
    // 2) заменить недопустимые символы на пробелы БЕЗ регулярок
    // 3) разбить строку по пробелам
    // 4) объединить через дефис
}

func slugifyRegexp(src string) string {
    // 1) привести строку к нижнему регистру
    // 2) заменить недопустимые символы на пробелы через регулярку
    // 3) разбить строку по пробелам
    // 4) объединить через дефис
}
```

(код не привожу, чтобы не спойлерить решения задач)

Отличие только в строке ➋, остальные шаги одинаковые.

А вот бенчмарки для этих функций:

```bash
Benchmark_slugify-8              1834732               640.4 ns/op           320 B/op          4 allocs/op
Benchmark_slugifyRegexp-8         566186              2053 ns/op             458 B/op          9 allocs/op
```

`slugifyRegexp()` хуже по всем показателям: в 3 раза медленнее, в 1.5 раза больше памяти, в 2 раза больше аллокаций.

Поэтому имеет смысл использовать регулярки только там, где выгода от них заметно перевешивает недостатки.

 [песочница](https://go.dev/play/p/lpGC1HCXXfD)

[[модуль Strings]]