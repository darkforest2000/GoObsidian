В Go нет исключений и блока try-catch, как в питоне или js. Вместо этого функции явно возвращают ошибку отдельным значением. Благодаря этому ошибки невозможно проигнорировать, а разработчики продумывают поведение программы в случае проблем.

Ошибки принято возвращать последним значением с интерфейсным типом `error`:

```go
func sqrt(x float64) (float64, error) {
    if x < 0 {
        return 0, errors.New("expect x >= 0")
    }
    // `nil` в качестве ошибки указывает, что ошибок не было.
    return math.Sqrt(x), nil
}
```

Проверим работу `sqrt()` на положительном и отрицательном значениях. Обратите внимание, как мы получаем результат и проверяем ошибку внутри условия `if` — это стандартная практика в Go.

```go
for _, x := range []float64{49, -49} {
    if res, err := sqrt(x); err != nil {
        fmt.Printf("sqrt(%v) failed: %v\n", x, err)
    } else {
        fmt.Printf("sqrt(%v) = %v\n", x, res)
    }
}
// sqrt(49) = 7
// sqrt(-49) failed: expect x >= 0
```



## Сравнение ошибок

Практически любая функция может вернуть разные ошибки. Хотелось бы уметь их анализировать и понимать, что происходит, для последующей работы. Например, база данных может возвращать ошибку `NoRows`, если искомые данные не найдены, однако это не всегда является нарушением логики работы программы.

Ошибки можно сравнивать так же, как и другие переменные:

```go
data, err := ReadTextFile()
// Проверяем, что была возвращена ошибка
if err != nil {
    if err == ErrFileReading {
        fmt.Println("unable read file")
        return 
    }
    fmt.Println("unknown error")
    return
}
 
```

Однако, нельзя сравнивать ошибку ни с чем, кроме как с `nil`, если она была сформирована динамически.

Далее узнаем, как разрешить эту проблему.



[[Основы GO]] [[Собственный тип ошибки]] 