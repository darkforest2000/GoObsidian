Мы столкнулись с типичной проблемой взаимодействия двух участников в многозадачной среде:

-   писатель пишет значения в канал;
-   читатель читает значения из канала;
-   как писателю информировать читателя, что значения закончились?

В Go есть механизм, который решает ровно эту задачу:

-   писатель может _закрыть_ (close) канал;
-   читатель может понять, что канал закрыт.

Писатель закрывает канал функцией `close()`:

```go
in := make(chan string)
go func() {
    words := strings.Split(str, ",")
    for _, word := range words {
        in <- word
    }
    close(in)
}()
```

Читатель проверяет статус канала вторым значением при считывании:

```go
for {
    word, ok := <-in
    if !ok {
        break
    }
    if word != "" {
        fmt.Printf("%s ", word)
    }
}
```

Допустим, в канал передают строки `one`, `two`, после чего закрывают его. Вот что получит при этом читатель:

```go
// in <- "one"
word, ok := <-in
// word = "one", ok = true

// in <- "two"
word, ok := <-in
// word = "two", ok = true

// close(in)
word, ok := <-in
// word = "", ok = false

word, ok := <-in
// word = "", ok = false

word, ok := <-in
// word = "", ok = false
```

Пока канал открыт, читатель получает очередное значение и статус `true`. Если канал закрыт, читатель получает нулевое значение (для строки это `""`) и статус `false`.

Как видно из примера, читать из закрытого канала можно сколько угодно — каждый раз вернется нулевое значение и статус `false`. Это неспроста — через несколько шагов разберемся, зачем так сделано.

Закрыть канал можно только один раз. Повторное закрытие приведет к панике:

```go
in := make(chan string)
close(in)
close(in)
// panic: close of closed channel
```

Записать в закрытый канал тоже не получится:

```go
in := make(chan string)
go func() {
    in <- "hi"
    close(in)
}()
fmt.Println(<-in)
// hi

in <- "bye"
// panic: send on closed channel
```

Отсюда два важных правила:

1.  _Закрыть канал имеет право только писатель, но не читатель_. Если читатель закроет канал, то писатель словит панику при следующей записи.
2.  _Писатель имеет право закрыть канал, только если владеет им единолично_. Если писателей несколько, и один из них закроет канал, то остальные словят панику при следующей записи или попытке закрыть канал со своей стороны.

>**Всегда ли закрывать канал**
>
	Наверняка вы раньше работали с внешними ресурсами (файлами, соединениями БД) — и знаете, что их всегда следует закрывать, чтобы не было утечки. Но канал — не внешний ресурс. Когда канал перестанет использоваться, сборщик мусора Go освободит занятые им ресурсы — вне зависимости от того, закрыт канал или нет.
>
	Закрывать канал стоит с единственной целью — сообщить его читателям, что все данные отправлены. Если читателей у канала нет, то и закрывать его не нужно.

[[Каналы]] [[Горутины]] 