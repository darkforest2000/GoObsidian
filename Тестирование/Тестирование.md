С библиотекой `testing` вы уже знакомы. В Go принято располагать файлы с unit-тестами непосредственно в пакете, функции которого вы тестируете. Например, если код, который вы хотите покрыть тестами, находится в файле `foo.go`, для тестов нужно создать файл `foo_test.go`:

```go
foo/ // пакет foo
    foo.go // файл с тестируемым кодом
    foo_test.go // файл с тестами 
```

Содержимое файла `foo.go`:

```go
package foo

func Foo() string {
    return "bar"
} 
```

В файле `foo_test.go` реализуем функции определённой сигнатуры:

```go
// файл foo_test.go
package foo

import (
    "testing"
)

func TestFooFunc(t *testing.T) {
    expectedFooResult := "bar"
    if actualFooResult := Foo(); actualFooResult != expectedFooResult {
        t.Errorf("expected %s; got: %s", expectedFooResult, actualFooResult)
    }
} 
```

Выполнить их можно, просто вызвав команду `go test`:

```bash
PASS
ok      github.com/Yandex-Practicum/go-freetrack/00_intro/testing/foo   0.240s 
```

Существует множество видов функциональных и нефункциональных тестов:

-   **Юнит-тесты** — тестируют минимальную часть функциональности (функцию или методы) в полной изоляции от внешних зависимостей. По сути, тестируются отдельные небольшие кусочки кода.
-   **Интеграционные тесты** — тестируют взаимодействие нескольких крупных частей приложения, например систем оформления заказов и оплаты.
-   **End-to-end-тесты** — тестируют работоспособность всей системы.
-   **Мутационные тесты** — тестируют код на устойчивость к случайным изменениям.
-   **Нагрузочные тесты** — используются для определения максимальной нагрузки, которую система способна выдержать с допустимым уровнем деградации.

		Напомним, что функциональные тесты проверяют работоспособность разработанного кода, то есть соответствие функциональным требованиям. Нефункциональные (например, нагрузочные) определяют соответствие кода требованиям надёжности, качества, сопровождения и т. п.

При компиляции тестов, как и основного кода, запрещены циклические импорты. Однако при написании тестов они могут возникать часто, поскольку в тестах может понадобиться код, который зависит от тестируемого кода. В таком случае тесты будут зависеть от тестируемого кода и, следовательно, импортировать сами себя. Поэтому для тестов сделали единственное исключение из правила «одна директория — один пакет». Тестовые файлы могут располагаться в пакете с суффиксом `_test` — и этой возможностью лучше пользоваться.

Также в пакете `_test` стоит располагать код, нужный исключительно для тестов. Допустим, надо сделать приватный тип публичным или добавить класс вспомогательных методов. Вспомогательный файл (часто его называют `harness_test.go` или `common_test`) может выглядеть так:

```go
package user

import "context"

type UserDAO = userDAO

func (p *userProvider) ResetAllCaches(ctx context.Context) error {
    // сбрасываем кеши провайдера
} 
```


## Тесты в Go

Теперь, когда вы знаете, где и как хранить тестовый код, поговорим о том, как именно писать тесты на Go.

В Go все тесты — это функции вида:

```go
func TestXxx(t *testing.T) 
```

Префикс `Test` обязателен. В качестве `Xxx` обычно указывают название тестируемой функции. У каждой тестируемой функции может быть несколько тестов, и тогда нужно указать дополнительную информацию по конкретному тесту.

Для примера протестируем функцию `Add`, которая должна сложить два числа при условии, что они положительные. Если одно или оба числа равны нулю, функция должна вернуть ошибку.

Файл `add.go`:

```
package math

import "errors"

func Add(a, b int) (int, error) {
    if a == 0 || b ==  0 {
        return 0, errors.New("arg is zero")
    }
    
    if a < 0 || b < 0 {
        return 0, errors.New("arg is negative")
    } 
    return a + b, nil
} 
```

Файл `add_test.go`:

```
package math

import "testing"

func TestAddPositive(t *testing.T) {
    sum, err := Add(1, 2)
    if err != nil {
        t.Error("unexpected error")
    }
    if sum != 3 {
        t.Errorf("sum expected to be 3; got %d", sum)
    }
}


func TestAddNegative(t *testing.T) {
    _, err := Add(-1, 2)
    if err == nil {
        t.Error("first arg negative - expected error not be nil" )
    }
    _, err = Add(1, -2)
    if err == nil {
        t.Error("second arg negative - expected error not be nil" )
    }
    _, err = Add(-1, -2)
    if err == nil {
        t.Error("all arg negative - expected error not be nil" )
    }
}
 
```

Объект `*testing.T` предоставляет доступ к нескольким базовым методам:

-   `Error`, `Errorf` — записывает сообщение в `error`-лог и помечает тест как непройденный. Исполнение теста продолжается.
-   `Fatal`, `Fatalf` — делает то же самое, но исполнение теста немедленно завершается. Этот метод часто используется в рабочих проектах при обработке ошибок. Очень удобен при отладке, когда тестируется какой-то конкретный участок кода.
-   `Skip`, `Skipf` — позволяет пропустить тест с сообщением. Используется, когда окружение для теста не задано. Типичный сценарий — прогон интеграционных тестов с внешним сервисом только на CI, где к нему есть доступы.
-   `Log`, `Logf` — позволяет выводить лог-сообщения внутри теста. Преимущество перед методами пакета `fmt` в том, что из лога сразу видно, к какому тесту относится сообщение.
-   `Run(name string, testf func(t *testing.T) )` — запускает функцию в качестве теста, что удобно при выполнении нескольких запусков теста, например, с разными именами.

## go test

Теперь разберём запуск написанных тестов. Для этого в экосистеме Go используется стандартная утилита [go test](https://golang.org/cmd/go/#hdr-Test_packages). Она позволяет запускать тесты следующими способами:

1.  Тесты на основании положения кода в директории. Чтобы запустить все тесты в директории, достаточно перейти в неё и выполнить команду `go test` или `go test -v`. Флаг `-v` перенаправляет на `stdout` всё, что тесты логируют в `stdout` и `stderr`.
2.  Все тесты пакета. Чтобы запустить все тесты в пакете, утилите `go test` надо передать пути импорта этих пакетов, разделённые пробелами. Например: `go test math github.com/username/packagename github.com/username/packagename2`.
3.  Тесты, подходящие под регулярное выражение. Также есть возможность протестировать некоторое подмножество тестов пакета. Для этого используется флаг `-run` утилиты `go test`.

Например, если нужно протестировать все тест-кейсы с префиксом `TestFunc` в пакете `github.com/ytuser/ytpackage`, вызов команды `go test` будет выглядеть так:

```
go test github.com/ytuser/ytpackage -run ^TestFunc 
```

В качестве аргумента передаётся регулярное выражение, под которое должны подходить названия тестов. Вот только регулярные выражения выходят за пределы темы урока, и если вы не знакомы с ними, то лучше сперва прочитать эту [статью](https://habr.com/ru/post/545150/).

### Кеширование тестов

Если повторно запустим команду `go test <PACKAGE_NAME>`, то увидим, что вывод команды изменился. В случае с пакетом `math` получим:

```
ok      math    (cached) 
```

Дело в том, что в режиме тестирования пакета `go test` кеширует результат прогона тестов и, если код и тесты не были изменены, использует закешированный результат.

Отключить кеширование можно двумя способами:

-   Передать флаг `-count 1`, который определяет, сколько раз нужно запустить каждый тест (по умолчанию — один). Соответственно, `-count 1` не изменяет количество запусков — если сравнивать со значением по умолчанию, — но выключает кеширование.
-   Запустить команду `go test clear`, очищающую кеш.

### Дополнительные настройки тестирования

-   `-cpu 1,2,4` — позволяет прогнать все тесты несколько раз с использованием разного количества потоков. Пригодится, если нужно протестировать параллельный код и убедиться, что на машинах с разным количеством ядер он будет работать корректно.
-   `-list regexp` — вместо того чтобы запускать тесты, `go test` выведет в консоль имена тестов, подходящих под переданное регулярное выражение.
-   `-parallel n` — позволяет параллельно выполнять тесты, которые в теле вызывают `t.Parallel`.
-   `-run regexp` — позволяет запускать конкретные тесты.
-   `-short` — если этот флаг передан, то `t.Short() == true`. В этом случае можно либо пропустить длительные тесты, либо урезать их функционал.
-   `-v` — подробное логирование. Даже в случае успешного прохождения тестов весь их лог будет выведен в консоль.

## Покрытие кода

Одна из важнейших метрик качества кода — **степень покрытия тестами** (**test coverage**). В Go для вычисления этой метрики используется флаг `-cover` утилиты `go test`, подробнее о котором можно почитать в [официальном блоге Go](https://blog.golang.org/cover).

Например, если вы хотите узнать степень покрытия тестами пакета `math` из стандартной библиотеки, надо вызвать команду `go test math -cover`:

```
ok      math    0.003s    coverage: 86.8% of statements 
```

Определим покрытие тестами функции `Add` из примера выше:

```
% go test -cover
PASS
coverage: 80.0% of statements
ok      tests_06        0.233s 
```

Но знания одной только метрики зачастую не хватает, и нужно выяснить, какие именно строки кода не были задействованы при прогоне тестов. Этот функционал тоже идёт «из коробки» в виде флага `-coverprofile` утилиты `go test` и специальной утилиты [go cover](https://golang.org/cmd/cover/) для анализа профиля покрытия тестами.

Итак, если вы хотите узнать, какой именно код пакета `math` не был покрыт тестами, надо сделать следующее:

1.  Запустить на нём утилиту `go test` и сохранить файл профиля покрытия тестами. Путь к файлу с профилем — это значение флага `-coverprofile`. В данном случае сохраним его в файл `coverage.out` текущей директории:

```
go test . -coverprofile=coverage.out 
```

2.  Проанализировать полученный файл утилитой `cover`. Например, по собранному профилю можно получить HTML-представление исходного кода с дополнительной разметкой, связанной с покрытием тестами:

```
go tool cover -html=coverage.out 
```

После выполнения автоматически запустится браузер, где будет отображена информация по покрытию.

![[img_1655834751.png]]

## Удобное тестирование

Можно тестировать код, используя только `*testing.T`, но он не предоставляет доступ к функциям вроде проверки на равенство, проверки на возврат ошибки или проверки на наличие паники при вызове переданного колбэка.

Этот пробел заполняют сторонние библиотеки, среди которых самая популярная — [testify](https://github.com/stretchr/testify). Следует отметить, что они не являются заменой стандартного `testing`, а расширяют и дополняют его.

[[Подготовка и завершение тестов]] [[Testify]] [[Основы Go]] [[Mock]] [[Избирательный запуск]]