В программировании _контекст_ (context) — это информация о среде, в которой существует объект или выполняется функция. В Go под контекстом обычно имеют в виду интерфейс `Context` из пакета `context`. Его придумали, чтобы облегчить работу с HTTP-запросами, так что мы еще встретим контексты в следующем модуле, посвященном стандартной библиотеке. Но контексты можно использовать и в обычном многозадачном коде. Давайте посмотрим, как именно.

### Отмена операции через канал

Рассмотрим функцию `execute()`, которая умеет запустить переданную функцию и поддерживает отмену:

```go
// выполняет функцию fn
func execute(cancel <-chan struct{}, fn func() int) (int, error) {
    ch := make(chan int, 1)

    go func() {
        ch <- fn()
    }()

    select {
    case res := <-ch:
        return res, nil
    case <-cancel:
        return 0, errors.New("canceled")
    }
}
```

Здесь все знакомо:

-   функция принимает канал, через который может получить сигнал отмены;
-   запускает `fn()` в отдельной горутине;
-   через `select` дожидается выполнения `fn()` либо прерывается по отмене, смотря что наступит раньше.

Напишем клиента, который отменяет операцию с 50% вероятностью:

```go
func main() {
    rand.Seed(time.Now().Unix())

    // работает в течение 100 мс
    work := func() int {
        time.Sleep(100 * time.Millisecond)
        fmt.Println("work done")
        return 42
    }

    // ждет 50 мс, после этого
    // с вероятностью 50% отменяет работу
    maybeCancel := func(cancel chan struct{}) {
        time.Sleep(50 * time.Millisecond)
        if rand.Float32() < 0.5 {
            close(cancel)
        }
    }

    cancel := make(chan struct{})

    go maybeCancel(cancel)

    res, err := execute(cancel, work)
    fmt.Println(res, err)
}
```

Запустим несколько раз:

```no-highlight
0 canceled

work done
42 <nil>

0 canceled

work done
42 <nil>
```

Без неожиданностей.

А теперь сделаем то же самое через контекст.

[песочница](https://go.dev/play/p/kKxlX6HckFk)


### Отмена операции через контекст

Основное назначение контекста в Go — отмена операций.

Повторим через контекст то, что мы только что сделали через канал отмены. Функция `execute()` будет принимать контекст `ctx` вместо канала `cancel`:

```go
// выполняет функцию fn с учетом контекста ctx
func execute(ctx context.Context, fn func() int) (int, error) {
    ch := make(chan int, 1)

    go func() {
        ch <- fn()
    }()

    select {
    case res := <-ch:
        return res, nil
    case <-ctx.Done():       // (1)
        return 0, ctx.Err()  // (2)
    }
}
```

Код почти не изменился:

-   вместо канала `cancel` сигнал об отмене может прийти из канала `ctx.Done()` ➊
-   вместо ручного создания ошибки при отмене возвращаем `ctx.Err()` ➋

Клиент тоже несколько меняется:

```go
func main() {
    // ...
    
    // работает в течение 100 мс
    work := func() int {
        // ...
    }

    // ждет 50 мс, после этого
    // с вероятностью 50% отменяет работу
    maybeCancel := func(cancel func()) {
        time.Sleep(50 * time.Millisecond)
        if rand.Float32() < 0.5 {
            cancel()
        }
    }

    ctx := context.Background()              // (1)
    ctx, cancel := context.WithCancel(ctx)   // (2)
    defer cancel()                           // (3)

    go maybeCancel(cancel)                   // (4)

    res, err := execute(ctx, work)           // (5)
    fmt.Println(res, err)
}
```

Вот что здесь происходит:

-   ➊ через `context.Background()` создаем пустой контекст;
-   ➋ через `context.WithCancel()` на базе пустого контекста создаем новый, с возможностью ручной отмены;
-   ➌ планируем отложенную отмену контекста при выходе из `main()`;
-   ➍ отменяем контекст с 50% вероятностью;
-   ➎ передаем контекст в функцию `execute()`.

`context.WithCancel()` возвращает сам контекст и функцию `cancel` для его отмены. Вызов `cancel()` освобождает занятые контекстом ресурсы и закрывает канал `ctx.Done()` — этот эффект мы и используем для прерывания `execute()`. Если контекст отменен, то `ctx.Err()` возвращает ошибку с причиной отмены (`context.Canceled` в нашем случае).

Все вместе работает точно так же, как предыдущая версия с каналом отмены:

```no-highlight
work done
42 <nil>

0 context canceled

0 context canceled

work done
42 <nil>
```

Пара нюансов, которых не было с каналом отмены:

**Контекст — это матрешка**. Объект контекста неизменяемый. Чтобы добавить контексту новые свойства, создают новый контекст («дочерний») на основе старого («родительского»). Поэтому мы сначала создали пустой контекст, а затем новый (с возможностью отмены) на его основе:

```
// родительский контекст
ctx := context.Background()

// дочерний
ctx, cancel := context.WithCancel(ctx)
```

Если отменить родительский контекст — отменятся и все дочерние (но не наоборот).

```go
// родительский контекст
parentCtx, parentCancel := context.WithCancel(context.Background())

// дочерний контекст
childCtx, childCancel := context.WithCancel(parentCtx)

// parentCancel() отменит parentCtx и childCtx
// childCancel() отменит только childCtx
```

**Многократная отмена безопасна**. Если два раза вызвать `close()` на канале, получим панику. А вот вызывать `cancel()` контекста можно сколько угодно. Первая отмена сработает, а остальные будут проигнорированы. Это удобно, потому что можно сразу после создания контекста запланировать отложенный `cancel()`, плюс явно отменить контекст при необходимости (как мы сделали в функции `maybeCancel`). С каналом бы так не получилось.

[[Горутины]] [[Таймаут Горутины]] [[Дедлайн Горутины]] [[Контекст со значениями]]