Как и большинство типизированных языков, Go позволяет программисту декларировать собственные типы. Так, под капотом тип `rune` определяется как `uint32`, а `byte` как `uint8`:

```go
type rune uint32
type byte uint8 
```

С помощью определений вы можете создавать новые типы, улучшая читаемость кода. Из-за строгости типизации вы ограничиваете определениями в том числе применимость функций и конструкций к вашим типам:

```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = fruit // ошибка типизации
             // cannot use fruit (variable of type Fruit) as type Name in assignment 
```

Чтобы исправить ошибку в этом листинге, нужно явно привести `fruit` к `Name`.

Для пользовательских типов можно определять методы (как для классов в ООП, об этом будет позже в курсе).

```go
// декларация пользовательского типа
type MyType string
// декларация метода для пользовательского типа
func (mt MyType) MethodForMyType() {
    //логика метода
} 
```

Определять методы для встроенных типов в Go нельзя.


## Приведение типов

Чтобы привести один тип к другому, в Go используется такой синтаксис: `type(variable)`. Проиллюстрируем на предыдущем примере:

```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = Name(fruit) // так, после приведения типов, работает 
```

## Псевдонимы

В Go также есть **псевдонимы (aliases)** — не путайте с определениями. Псевдонимы позволяют обращаться к типу в коде по другому имени. По синтаксису они похожи на определения:

```go
type MyString = string // MyString здесь — это псевдоним типа string

var a string // можно использовать одно из этих условий для проверки пустой строки
var b MyString
a = b // ошибки нет 
```

Можно смешивать псевдонимы и изначальные типы в одном выражении.

Псевдонимы были введены в язык по настоянию Google — для решения задач крупной компании, владельца больших, смежных, пересекающихся `code base` массивов кода. Применение псевдонимов облегчает масштабный рефакторинг большого объёма уже написанного кода из разных источников. При написании «свежего» кода с чистого листа лучше обходиться без псевдонимов.


## Определяемые типы

Новый тип не обязательно создавать на основе структуры — можно использовать любые базовые типы.

Создадим тип «ИНН» на основе строки:

```go
type inn string
```

Тип `inn` (он называется _определяемым типом_, defined type) получил свойства базового типа `string`. Добавим ему новое поведение с помощью метода:

```go
func (id inn) isValid() bool {
    if len(id) != 12 {
        return false
    }
    for _, char := range id {
        if !unicode.IsDigit(char) {
            return false
        }
    }
    return true
}
```

```go
inn1 := inn("111201284667")
fmt.Println("inn", inn1, "is valid:", inn1.isValid())
// inn 111201284667 is valid: true

inn2 := inn("ohmyinn12345")
fmt.Println("inn", inn2, "is valid:", inn2.isValid())
// inn ohmyinn12345 is valid: false
```

Это чем-то похоже на наследование, но механизм более примитивный. Если создать новый определяемый тип на основе `inn` — он унаследует структуру и свойства `inn`, но не методы:

```go
type otherid inn
```

```go
other := otherid("111201284667")
fmt.Println("other inn", other, "is valid:", other.isValid())
// ОШИБКА: other.isValid undefined
```


[[Методы]] [[Структуры]]