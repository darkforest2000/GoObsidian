
_Структура_ (struct) группирует поля в единую запись. В Go нет классов и объектов, так что структура — наиболее близкий аналог объекта в питоне и js.

Объявим тип `person` на основе структуры с полями `name` и `age`:

```go
type person struct {
    name string
    age  int
}
```

Так создается новая структура типа `person`:

```go
bob := person{"Bob", 20}
fmt.Println(bob)
// {Bob 20}
```

Можно явно указать названия полей:

```go
alice := person{name: "Alice", age: 30}
fmt.Println(alice)
// {Alice 30}
```

Если не указать поле, оно получит нулевое значение:

```go
fred := person{name: "Fred"}
fmt.Println(fred)
// {Fred 0}
```

Оператор `&` возвращает указатель на структуру:

```go
annptr := &person{name: "Ann", age: 40}
fmt.Println(annptr)
// &{Ann 40}
```

В Go иногда создают новые структуры через функцию-конструктор с префиксом `new`:

```go
func newPerson(name string) *person {
    p := person{name: name}
    p.age = 42
    return &p
}
```

Функция возвращает указатель на локальную переменную — это нормально. Go распознает такие ситуации, и выделяет память под структуру в куче (heap) вместо стека (stack), так что структура продолжит существовать после выхода из функции.

```
john := newPerson("John")
fmt.Println(john)
// &{John 42}
```

Если функция-конструктор возвращает саму структуру, а не указатель — удобно использовать префикс `make` вместо `new`:

```go
func makePerson(name string) person {
    p := person{name: name}
    p.age = 42
    return p
}
```

> В реальности чаще не заморачиваются и всегда используют префикс new вне зависимости от того, что возвращает конструктор — значение или указатель на него. Но на курсе я буду соблюдать это разделение: make — значение, new — указатель.

Доступ к полям структуры — через точку:

```go
sean := person{name: "Sean", age: 50}
fmt.Println(sean.name)
// Sean
```

Чтобы получить доступ к полям структуры через указатель, не обязательно разыменовывать его через `*`. Эти два варианта эквивалентны:

```go
sven := &person{name: "Sven", age: 50}
fmt.Println((*sven).age)
fmt.Println(sven.age)
// 50
```

Поля структуры можно изменять:

```go
sven.age = 51
fmt.Println(sven.age)
// 51
```


### Составные структуры

Структуры могут включать другие структуры:

```go
type person struct {
    firstName string
    lastName  string
}

type book struct {
    title  string
    author person
}
```

```go
b := book{
    title: "The Majik Gopher",
    author: person{
        firstName: "Christopher",
        lastName:  "Swanson",
    },
}
fmt.Println(b)
// {The Majik Gopher {Christopher Swanson}}
```

Если вложенная структура не представляет самостоятельной ценности, можно даже не объявлять отдельный тип:

```go
type user struct {
    name  string
    karma struct {
        value int
        title string
    }
}
```

```go
u := user{
    name: "Chris",
    karma: struct {
        value int
        title string
    }{
        value: 100,
        title: "^-^",
    },
}
fmt.Printf("%+v\n", u)
// {name:Chris karma:{value:100 title:^-^}}
```

Благодаря шаблону `%+v`, `Printf()` печатает структуру вместе с названиями полей.

Поле структуры может ссылаться на другую структуру:

```go
type comment struct {
    text   string
    author *user
}
```

```go
chris := user{
    name: "Chris",
}
c := comment{
    text:   "Gophers are awesome!",
    author: &chris,
}
fmt.Printf("%+v\n", c)
// {text:Gophers are awesome! author:0xc0000981e0}
```

## Инициализация

Существует несколько подходов к созданию экземпляра объекта.

**1. Пустой объект**

```
p := Person{}
// или
var p Person 
```

Все поля структуры при таком подходе принимают значения по умолчанию.

Подход применяют:

-   когда экземпляр не требует специальной инициализации и может быть использован дальше по коду;
-   когда для инициализации полей нужны дополнительные условия и данные, то есть выставление значений конкретных полей будет следовать ниже по коду.

**2. Неявное указание значений полей**

```
date := time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)
p := Person{ "Иван", "ivan@yandex.ru", date } 
```

При таком подходе перечисляют значения для всех полей структуры, используя литералы либо значения внешних переменных.

Требования:

-   Нужно перечислить все поля объекта.
-   Порядок следования аргументов инициализатора должен совпадать с порядком описания полей структуры. Если поставить поле `Email` на первое место в описании `type Person struct`, инициализация экземпляра выше будет некорректна (с точки зрения логики, но не компилятора).

Подход применяют:

-   когда нужно явно указать значения всех полей объекта;
-   когда вы уверены, что спецификация типа не будет меняться часто, иначе придётся вносить правки для каждого инициализатора объекта в коде.

**3. Явное указание значений полей**

```
p := Person{ Name: "Иван", Email: "ivan@yandex.ru" } 
```

При таком подходе явно указывают имена полей и их значения.

Особенности:

-   этот подход отличается от первого опциональным указанием полей;
-   порядок указания полей не важен;
-   значения полей, которые не были использованы в инициализаторе (`dateOfBirth` в примере), примут значения по умолчанию.

Для повышения читабельности кода такую инициализацию часто описывают в несколько строк, что справедливо и для второго подхода:

```
p := Person{
    Name: "Иван",
    Email: "ivan@yandex.ru",
} 
```


Подход применяют:

-   почти всегда, так как он лишён ограничений, описанных выше.

На практике обычно применяется явное указание имён, потому что оно снижает количество возможных ошибок.

**4. Конструктор**

Учитывая тонкости при инициализации сложного объекта, разработчики применяют конструкторы.

В Go нет синтаксиса конструкторов и деструкторов, но часто можно встретить аналог:

```go
   func NewPerson(name, email string, dobYear, dobMonth, dobDate int) Person {
       return Person{
           Name:        name,
           Email:       email,
           dateOfBirth: time.Date(dobYear, time.Month(dobMonth), dobDate, 0, 0, 0, 0, time.UTC),
       }
   } 
```

Вот некоторые правила, одобренные Go-сообществом:

-   имя функции конструктора пишут с префиксом `New`;
-   если конструктор производит валидацию аргументов, функция должна возвращать ошибку последним аргументом.

Можем вернуться к нашему примеру, чтобы добавить проверку корректности `email` и числовых компонент даты — тогда декларация функции примет вид:
```go
func NewPerson(name, email string, dobYear, dobMonth, dobDate int) (Person, error) {} 
```

Подход применяют:

-   когда нужно производить валидацию аргументов, чтобы построить логически правильный объект;
-   когда построение экземпляра объекта требует дополнительных действий, например подключения к базе данных.

![[3.4_1638892995.png]]


## Область видимости

Как вы уже знаете, в Go есть понятия **экспортируемых** и **неэкспортируемых** типов. Код разделяется на пакеты, и, чтобы тип, функция или глобальная переменная были доступны в другом пакете, их имена должны начинаться с заглавной буквы. Это же правило работает для полей и методов структуры.

![image](https://pictures.s3.yandex.net:443/resources/1.4.export_1638893029.png)

В примере выше `Person` — экспортируемый тип (публичный). Другие пакеты могут создавать экземпляры этого типа и иметь доступ к публичным полям `Name` и `Email`. А поле `dateOfBirth` — неэкспортируемое (приватное).

Приведём пример экспортирования приватного типа:

```go
package foo

// privateFoo — неэкспортируемый тип
type privateFoo struct {
    Value string
}

// NewPrivateFoo — конструктор типа privateFoo
// Функция публичная, то есть может быть вызвана из других пакетов
func NewPrivateFoo() privateFoo {
    return privateFoo{Value: "some data"}
} 
```

```go
package main

import "github.com/the_greatest_coder/hello_go/foo"

func main() {
    // f := foo.privateFoo{} // ошибка компиляции
    f := foo.NewPrivateFoo()
    fmt.Println(f.Value) // поле Value экспортируемое, то есть его можно использовать
} 
```

```
some data 
```

## Теги

У каждого поля структуры может быть набор аннотаций, которые называются **тегами (tags)**:

```go
type GetUserRequest struct {
    UserId string `json:"user_id" yaml: "user_id" format:"uuid" example:"2e263a90-b74b-11eb-8529-0242ac130003"`
    IsDeleted *bool `json:"is_deleted,omitempty" yaml:"is_deleted"`
} 
```

Теги не влияют на представление или работу с данными напрямую, но могут использоваться пакетами для получения дополнительной информации о конкретном поле.

Набор тегов с их значениями можно представить как набор ключей и значений, где ключи разделяются пробелами, а значения ключей — запятой.

В примере выше встречаются следующие теги:

-   `json` — используется пакетом [encoding/json](https://golang.org/pkg/encoding/json/) для сериализации/десерилизации структур в JSON;
-   `yaml` — похож на `json`, но используется внешними библиотеками для работы с форматом YAML;
-   `format` и `example` — могут быть как подсказкой для разработчика, так и аннотацией для генерации Swagger-описания (к примеру, библиотекой [swag](https://github.com/swaggo/swag)).

Применяемые аннотации чаще всего зависят от используемой библиотеки. Возможные ключи и значения стоит искать в документации пакета (в худшем случае — в коде).

Разработчик может вводить свои теги и работать с ними через пакет `reflect` стандартной библиотеки.

## Задание 2

Для сериализации используется функция `json.Marshal()` пакета `json`. Дана структура:

```go
type Person struct {
    Name        string
    Email       string
    DateOfBirth time.Time
} 
```

```go
type Person struct {  
   Name        string    `json:"Имя"`  
   Email       string    `json:"Почта"`  
   DateOfBirth time.Time `json:"-"`  
}  
p := Person{"Egor", "lol@mail.ru", time.Now()}  
mar, err := json.Marshal(p)  
if err != nil {  
   fmt.Println("Can't serislize", p)  
}  
fmt.Println(string(mar))

// {"Имя":"Egor","Почта":"lol@mail.ru"}
```

## Анонимные структуры

Анонимные структуры объявляются и используются непосредственно в коде. Отдельный тип для них не описывают, потому что анонимные структуры применяются однократно, и описание имеет смысл только для конкретной части кода: например, при сериализации/десериализации сообщений. Чаще всего анонимные структуры используют в тестах для описания тестовых структур.

Проще всего понять концепцию анонимных структур из следующего соображения:

```go

type Person struct {
    Name string 
} 
```

Конструкция `type Person ...` на самом деле не описывает, а создаёт тип на основе существующего и называет его. То есть по факту тип создаёт именно конструкция `struct{}`.

Получив такой анонимный тип, можно сразу же создать переменную этого типа.

Приведём пример использования анонимной структуры при построении REST-запроса:

```go
req := struct {
    NameContains string `json:"name_contains"`
    Offset       int    `json:"offset"`
    Limit        int    `json:"limit"`
}{
    NameContains: "Иван",
    Limit:        50,
}

reqRaw, _ := json.Marshal(req)
fmt.Println(string(reqRaw)) 
```

```
{"name_contains":"Иван","offset":0,"limit":50} 
```

Здесь мы описали анонимную структуру, инициализировали её экземпляр, произвели JSON-сериализацию и вывели результат в виде строки.

## struct{}

```go
var c struct{}
// или
c := struct{}{}

fmt.Println(unsafe.Sizeof(c))
fmt.Println(unsafe.Pointer(&c)) 
```

```
0
0x11d46e8 
```

Размер `struct{}` равен `0`, при этом объект `c` имеет адрес. Такую лазейку можно использовать для оптимизации кода по памяти, а в дальнейшем разберём это на практике.

Если структура содержить еще одну структуру, то оформить надо так:

```go
type Response struct {  
   Header header   `json:"header"`  
   Data   RespData `json:"data,omitempty"`  
}

type RespData []RespDataItem  
  
type RespDataItem struct {  
   UserType   string     `json:"type"`  
   Id         int        `json:"id"`  
   Attributes attributes `json:"attributes"`  
}  
```




[[Основы GO]] 
