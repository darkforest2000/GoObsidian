Запускать горутины в неприличных количествах — это, конечно, здорово. Но как им обмениваться данными? В Go горутины могут передавать друг другу значения через _каналы_ (channels). Канал — это окошко, в которое одна горутина может что-нибудь бросить, а вторая — поймать.

```no-highlight
┌─────────────┐    ┌─────────────┐
│ goroutine A │    │ goroutine B │
│             └────┘             │
│        X <-  chan  <- X        │
│             ┌────┐             │
│             │    │             │
└─────────────┘    └─────────────┘
```

_Горутина B передает значение X в горутину A. Холст, масло._

Вот как это работает:

```go
func main() {
    // Канал создается через `make(chan тип)`
    // и может передавать только значения указанного типа:
    messages := make(chan string)

    // Чтобы отправить значение в канал,
    // используют синтаксис `канал <-`
    // Отправим «пинг»:
    go func() { messages <- "ping" }()

    // Чтобы получить значение из канала,
    // используют синтаксис `<-канал`
    // Получим «пинг» и напечатаем его:
    msg := <-messages
    fmt.Println(msg)
}
```

Когда запустим программу, одна горутина (анонимная) передаст сообщение второй (main) через канал messages:

```bash
$ go run channels.go 
ping
```

Передача значения через канал — синхронная операция. Когда горутина-отправитель говорит `messages <- "ping"`, она блокируется и ждет, пока с другой стороны кто-нибудь примет значение через `<-messages`. Только после этого она возобновит выполнение:

```go
func main() {
    messages := make(chan string)

    go func() {
        fmt.Println("B: Sending message...")
        messages <- "ping"                    // (1)
        fmt.Println("B: Message sent!")       // (2)
    }()

    fmt.Println("A: Doing some work...")
    time.Sleep(500 * time.Millisecond)
    fmt.Println("A: Ready to receive a message...")

    <-messages                               //  (3)

    fmt.Println("A: Messege received!")
    time.Sleep(100 * time.Millisecond)
}
```

```bash
$ go run channels.go 
A: Doing some work...
B: Sending message...
A: Ready to receive a message...
A: Messege received!
B: Message sent!
```

Отправив сообщение в канал ➊, горутина B заблокировалась. Только после того, как горутина A приняла сообщение ➌, горутина B возобновила выполнение и смогла напечатать «message sent» ➋.

Таким образом, через каналы не только передают данные, но еще и используют их, чтобы синхронизировать независимые горутины. Это нам еще пригодится.

[песочница](https://go.dev/play/p/svz3XlcjvyS)





[[Горутины]] [[Закрытие каналов]] [[Итерирование по каналу]] [[Направленные каналы]] [[Канал завершения]] [[Буферизованные каналы]] [[Закрыть буферизованный канал]] [[Объединение каналов]]