Точка входа в программу — функция `main()`. Она обязательно должна существовать в единственном виде и в любой исполняемой программе на Go. `main()` не принимает аргументов и не возвращает значений.

В Go есть встроенные функции, например: `make()`, `new()`, `len()`, `cap()`, `delete()`, `close()`, `append()`, `copy()`, `panic()`, `recover()`. Это не библиотечные функции. Они не вполне подчиняются правилам для функций пользователя. У них может не быть сигнатуры, а их использование документировано в спецификации языка — основополагающем для Go документе.

В базовом синтаксисе языка также описана вот эта функция:

```go
func init() { … } 
```

В пакете и даже в одном файле можно декларировать несколько таких функций. Они будут вызваны один раз при инициализации пакета, после присвоения глобальных переменных, в том порядке, в котором они предоставлены компилятору (встречаются в исходном тексте). Прямой вызов функции `init()` в коде программы не предусмотрен.

Служат эти функции для создания окружения, необходимого пакету для корректной работы.

Вот простой пример:

```go
var name, surname string

func init() {
    name = "John"
}
func init() {
    if surname == "" {
        surname = "Doe"
    }
}
```

В Go нет конструкторов в классическом ООП-понимании. Есть встроенные аллокаторы `make()` и `new()`, которые инициализируют поля в их нулевые значения. Необходимые параметры устанавливаются литерально, присваиванием.

```go
type Person struct {
    Name string
    Surname string
    Age int
}

john := Person{Name: "John", Surname: "Doe", Age: 21}
john.Age = 27 
```

Это не очень технологично. Предположим, нам нужно инициализировать однотипные элементы значениями по умолчанию, но с возможностью задать некоторые параметры.

```go
type Item struct {
    NoOption string
    Parameter1 string
    Parameter2 int
}
 
```

Сделаем свой конструктор с опциями.

```go
func NewItem(opts ...option) *Item {
    // инициализируем типовыми значениями
    i := &Item{
        NoOption: "usual",
        Parameter1: "default",
        Parameter2: 42,
    }
    // применяем опции в том порядке, в котором они были заявлены
    for _, opt := range opts {
        opt(i)
    }
    return i
} 
```

Здесь опции — это функции, применяемые к объекту. За это подход получил название **funcopts**.

```go
type option func(*Item) 
```

Чтобы устанавливать параметры, будем использовать функции высшего порядка, возвращающие значениями функции `option`.

```go
func Option1(option1 string) option {
    return func(i *Item) {
        i.Parameter1 = option1
    }
}
func Option2(option2 int) option {
    return func(i *Item) {
        i.Parameter2 = option2
    }
} 
```

Тогда инициализация объекта конструктором будет выглядеть так:

```go
func main() {
    // с параметрами по умолчанию
    item1 := NewItem()
    // с применением одной опции
    item2 := NewItem(Option2(70))
    // или двух
    item3 := NewItem(Option1("unusual"), Option2(99))
    // опции можно заявлять в разном порядке
    item4 := NewItem(Option2(88), Option1("rare"))
} 
```