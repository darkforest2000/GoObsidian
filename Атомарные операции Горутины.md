### (sync/atomic)

Вернемся к примеру с гонками при увеличении общего счетчика:

```go
func main() {
    var wg sync.WaitGroup

    total := 0

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for i := 0; i < 10000; i++ {
                total++
            }
        }()
    }

    wg.Wait()
    fmt.Println("total", total)
}
```

[песочница](https://go.dev/play/p/vPXn49kpgDR)

5 горутин, каждая увеличивает `total` 10000 раз — итого получается 50000. Проверим:

```no-highlight
$ go run total.go
total 26775
$ go run total.go
total 22978
$ go run total.go
total 30357
```

Детектор гонок сигнализирует о проблеме:

```no-highlight
$ go run -race total.go
==================
WARNING: DATA RACE
...
==================
total 33274
Found 1 data race(s)
```

Выглядит странно. Ладно доступ к карте, но операция `total++` уж точно должна быть атомарной? На самом деле, нет. Она превращается в несколько отдельных инструкций процессора. Если часть инструкций выполнит одна горутина, а часть другая — это может нарушить целостность памяти. В результате часть инкрементов счетчика «пропадает».

Атомарной операция может быть только в одном случае — если она превращается в одну инструкцию процессора. Атомарные операции не требуют блокировок и не создают проблем при одновременном вызове. Даже операции записи.

В идеальном мире все операции были бы атомарными, и нам не пришлось бы возиться с мьютексами. На практике же атомарных операций совсем немного, и все они сосредоточены в пакете `[sync/atomic](https://pkg.go.dev/sync/atomic)`:

```go
func AddInt32(addr *int32, delta int32) (new int32)
func LoadInt32(addr *int32) (val int32)
func StoreInt32(addr *int32, val int32)
// есть и другие, но мы не будем их рассматривать
```

`Store()` записывает значение переменной, `Load()` считывает значение переменной а `Add()` увеличивает значение переменной на указанную дельту. Функции принимают адрес переменной, чтобы работать с оригиналом, а не копией. Все они выполняются за одну инструкцию процессора, поэтому безопасны для одновременных вызовов.

Кроме `int32`, есть аналогичные функции для `int64` и некоторых других типов.

Перепишем программу на использование атомиков:

```go
func main() {
    var wg sync.WaitGroup

    var total int32

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for i := 0; i < 10000; i++ {
                atomic.AddInt32(&total, 1)
            }
        }()
    }

    wg.Wait()
    fmt.Println("total", atomic.LoadInt32(&total))
}
```

```no-highlight
$ go run -race total.go
total 50000
```

Другое дело!

[песочница](https://go.dev/play/p/VUWzmiIGDyT)