С записью данных ситуация похожа на чтение, поэтому изложу кратко.

#### os.WriteFile

Если данных немного, записать их можно в один заход с помощью `os.WriteFile()`:

```go
people := []string{"Дарья", "Борис", "Елена", "Ксения", "Леонид"}
text := strings.Join(people, "\n")

err := os.WriteFile("people.txt", []byte(text), 0644)
if err != nil {
    panic(err)
}
```

Третий аргумент в `os.WriteFile()` задает права на доступ к файлу. `0644` означает, что записывать в этот файл сможет только владелец, а остальные пользователи — только читать. Распространенные наборы прав:

-   `0600` — владелец читает и пишет, остальные не имеют доступа;
-   `0644` — владелец читает и пишет, остальные только читают;
-   `0666` — все читают и пишут.

#### bufio.Writer

Для порционной записи предусмотрен интерфейс `io.Writer` с методом `Write()`:

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Есть конкретные типы, которые его реализуют: `bufio.Writer`, `strings.Builder` (знакомый вам по уроку «Текст»), `bytes.Buffer` и другие.

Для записи в файл удобно использовать `bufio.Writer`. Он подходит для бинарных и текстовых данных:

```go
file, err := os.Create("people.txt")  // (1)
if err != nil {
    panic(err)
}

people := []string{"Дарья", "Борис", "Елена", "Ксения", "Леонид"}
writer := bufio.NewWriter(file)
for _, p := range people {
    writer.WriteString(p)             // (2)
    writer.WriteByte('\n')            // (3)
}

err = writer.Flush()                  // (4)
if err != nil {
    file.Close()                      // (5)
    panic(err)
}

err = file.Close()                    // (6)
if err != nil {
    panic(err)
}
```

`os.Create()` создает файл для записи ➊.

Помимо стандартного метода `Write()`, у `bufio.Writer` есть методы для записи строк `WriteString()` ➋, отдельных байт `WriteByte()` ➌ и рун `WriteRune()`.

Метод `Flush()` ➍ принудительно записывает данные из внутренного буфера на диск. Мы вызываем его, поскольку закончили работать с файлом. При ошибке закрываем файл, прежде чем паниковать ➎.

`file.Close()` может вернуть ошибку ➏. При записи в файл игнорировать ее не стоит — такая ошибка может сигнализировать, что часть данных не были записаны. Поэтому паникуем, если что-то пошло не так.

Чтобы дописать данные в существующий файл, используют `os.OpenFile()` с подходящими параметрами. Код для записи данных при этом не меняется:

```go
file, err := os.OpenFile("people.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
if err != nil {
    panic(err)
}

people := []string{"Марина", "Иван", "Вероника"}
writer := bufio.NewWriter(file)
// дальше без изменений
```

`os.O_WRONLY` устанавливает, что в файл будем только писать, но не читать. `os.O_APPEND|os.O_CREATE` говорят, что в файл следует дописывать, если он существует, иначе создать.

Аналога `bufio.Scanner` для записи данных нет, потому что `bufio.Writer` и так отлично справляется.

[[Стандартная библиотека]]