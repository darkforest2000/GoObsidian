Тип `bufio.Reader` умеет читать данные как `os.File`, но делает это более эффективно. Внутри у него собственный буфер размера 4096 байт, так что `bufio.Reader` всегда сначала начитывает данные из файла в этот буфер, а затем уже отдает в методе `Read()`.

За счет этого получается меньше обращений к диску. Даже если мы читаем файл размера 100 Кб кусочками размером в 1 байт, то фактических обращений к диску получится только 100 * 1024 / 4096 + 1 = 26 раз (+1 обращение нужно, чтобы отследить конец файла).

```go
file, err := os.Open("awesome.txt")
if err != nil {
    panic(err)
}
defer file.Close()

reader := bufio.NewReader(file)  // (1)
buf := make([]byte, 5)
for {
    n, err := reader.Read(buf)
    if err == io.EOF {
        break
    }
    if err != nil {
        panic(err)
    }
    fmt.Printf("read %d bytes: %q\n", n, buf[:n])
}
```

Как видите, программа почти не отличается от той, что использовала `os.File.Read()`. Разница только в том, что вместо объекта `os.File` мы используем `bufio.Reader`, созданный на его основе ➊.

Результат тоже не отличается:

```http
read 5 bytes: "go is"
read 5 bytes: " awes"
read 3 bytes: "ome"
```

Но если `File.Read()` обращался к диску 4 раза, то `Reader.Read()` — только 2 (самый первый и последний, который вернет `io.EOF`). После первого вызова все содержимое файла поместилось во внутренний буфер, и следующие вызовы `Read()` возвращали данные уже оттуда.

`bufio.Reader` отлично подходит для чтения больших файлов. Кроме того, у него много приятных дополнительных возможностей:

-   размер буфера настраивается через конструктор `NewReaderSize()`;
-   можно подсмотреть следующие n байт через метод `Peek()` или пропустить их через `Discard()`;
-   можно считать отдельный байт через `ReadByte()` или руну через `ReadRune()`;
-   можно считать все байты до указанного разделителя через `ReadBytes()`;
-   или аналогично считать строку до указанного разделителя через `ReadString()`.

А вот чего `bufio.Reader` не умеет в сравнении с `os.File` — так это перемещаться в произвольном порядке по файлу с помощью метода `Seek()`. Так что если вам зачем-то понадобится такая возможность — используйте `os.File`.

[[Стандартная библиотека]]