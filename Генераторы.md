Go — язык с **лексической областью видимости (lexically scoped)**. Это значит, что переменные, определённые в окружающих блоках видимости (например, глобальные переменные), доступны функции всегда, а не только на время вызова. Можно считать, что функция их запоминает.

Лексическая область видимости и анонимные функции позволяют реализовать **замыкания (closure)**.

Вот классический пример итератора чётных чисел, построенного на замыкании:

```go
func Generate(seed int) func() {
    return func() {
        fmt.Println(seed) // замыкание получает внешнюю переменную seed
        seed += 2 // переменная модифицируется
    }
    
}

func main() {
    iterator := Generate(0)
    iterator()
    iterator()
    iterator()
    iterator()
    iterator()
}
```
Замыкание привязывает к себе внешнюю переменную. После выхода из внешней функции `Generate` она не уничтожается, а остаётся привязанной к функции замыкания, причём её значение сохраняется между вызовами функции.

Получаем:

```bash
0
2
4
6
8 
````

А вот и упоминавшиеся числа Фибоначчи, но теперь написанные с применением замыкания:

```go
func fib() func() int {
    x1, x2 := 0, 1
    // возвращаемая функция замыкает x1, x2
    return func() int {
        x1, x2 = x2, x1+x2
        return x1
    }
}

func main() {
    f := fib() // получили функцию-замыкание. f() — захватила x1, x2. x1 = 0, x2 = 1
    fmt.Println(f()) // x1 = 1, x2 = 1
    fmt.Println(f()) // x1 = 1, x2 = 2
    fmt.Println(f()) // x1 = 2, x2 = 3
    fmt.Println(f()) // x1 = 3, x2 = 5
    fmt.Println(f()) // x1 = 5, x2 = 8
    fmt.Println(f()) // x1 = 8, x2 = 13

} 
```

Такие функции иногда называют **[генераторами]**. Они выдают новое значение какой-либо последовательности при каждом вызове.

Замыкания довольно полезные. Они позволяют просто и изящно реализовать определённые паттерны проектирования. Тем не менее, чтобы эффективно использовать замыкания, надо представлять, как они работают.

Приведём более практичный пример использования замыкания. Создадим две функции-обёртки, одна из которых будет подсчитывать количество вызовов, а вторая — время исполнения функции.

```go
// countCall — функция-обёртка для подсчёта вызовов
func countCall(f func(string)) func(string) {
    cnt := 0
    // получаем имя функции. Подробнее об этом вызове будет рассказано в следующем курсе
    funcname := runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()
    return func(s string) {
        cnt++
        fmt.Printf("Функция %s вызвана %d раз\n", funcname, cnt)
        f(s)
    }
}

// metricTimeCall — функция-обёртка для замера времени
func metricTimeCall(f func(string)) func(string) {
    return func(s string) {
        start := time.Now() // получаем текущее время
        f(s)
        fmt.Println("Execution time: ", time.Now().Sub(start)) // получаем интервал времени как разницу между двумя временными метками
    }
}

func myprint(s string) {
    fmt.Println(s)
}

func main() {

    countedPrint := countCall(myprint)
    countedPrint("Hello world")
    countedPrint("Hi")

    // обратите внимание, что мы оборачиваем уже обёрнутую функцию, а значение счётчика вызовов при этом сохраняется
    countAndMetricPrint := metricTimeCall(countedPrint)
    countAndMetricPrint("Hello")
    countAndMetricPrint("World")

}
// Результат

Функция main.myprint вызвана 1 раз
Hello world
Функция main.myprint вызвана 2 раз
Hi
Функция main.myprint вызвана 3 раз
Hello
Execution time:  3.147µs
Функция main.myprint вызвана 4 раз
World
Execution time:  3.16µs
 
```

Вот ещё интересный пример применения замыкания. Вспомним функцию `PrintAllFilesWithFilter`, с которой мы недавно работали. Её недостаток в том, что параметр `filter` передаётся при каждом рекурсивном вызове. От этого можно избавиться, используя анонимную функцию в качестве замыкания.

```go
func PrintAllFilesWithFilterСlosure(path string, filter string) {
    // создаём переменную, содержащую функцию обхода
    // мы создаём её заранее, а не через оператор :=, чтобы замыкание могло сослаться на него
    var walk func(string)
    walk = func(path string) {
        // получаем список всех элементов в папке (и файлов, и директорий)
        files, err := ioutil.ReadDir(path)
        if err != nil {
            fmt.Println("unable to get list of files", err)
            return
        }
        //  проходим по списку
        for _, f := range files {
            // получаем имя элемента
            // filepath.Join — функция, которая собирает путь к элементу с разделителями
            filename := filepath.Join(path, f.Name())
            // печатаем имя элемента, если путь к нему содержит filter, который получим из внешнего контекста
            if strings.Contains(filename, filter) {
                fmt.Println(filename)
            }
            // если элемент — директория, то вызываем для него рекурсивно ту же функцию
            if f.IsDir() {
                walk(filename)
            }
        }
    }
    // теперь вызовем функцию walk
    walk(path)
}
 
```

Теперь неизменяющийся параметр не копируется на каждом шаге рекурсии. Замыкание просто ссылается на его значение, повышая скорость работы программы и снижая вероятность ошибки.

[[Функции]] [[Анонимные функции]] [[Особенные функции]]