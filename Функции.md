_Функция_ — центральная конструкция языка. Вот несколько примеров.

Эта функция принимает два целых числа и возвращает их сумму:

```go
func sum(a int, b int) int {
    return a + b
}
```

Результат возвращается явно, через `return`.

Если у нескольких идущих подряд параметров один и тот же тип, их можно «схлопнуть» и указать тип только для последнего:

```go
func sum(a, b, c int) int {
    return a + b + c
}
```

Функция может возвращать несколько значений. В этом примере — частное и остаток от деления одного числа на другое:

```go
func divide(divisible, divisor int) (int, int) {
    quotient := divisible / divisor
    remainder := divisible % divisor
    return quotient, remainder
}
```

Результат вызова можно сразу разложить по переменным:

```go
q, r := divide(10, 3)
fmt.Println("10 / 3 =", q)
// 10 / 3 = 3
fmt.Println("10 % 3 =", r)
// 10 % 3 = 1
```

Или проигнорировать одно из значений с помощью пустого идентификатора `_`:

```go
_, r = divide(42, 2)
if r == 0 {
    fmt.Println("42 is divisible by 2")
}
// 42 is divisible by 2
```

### Вариативные функции

Функция может принимать произвольное количество аргументов в «хвосте» (как _*args_ в питоне или _...args_ в js). Например, так ведет себя `fmt.Println()`. В Go такие функции называют _вариативными_ (variadic).

Эта функция суммирует целые числа:

```go
func sum(nums ...int) {
    fmt.Print(nums, " -> ")
    total := 0
    for _, num := range nums {
        total += num
    }
    fmt.Println(total)
}
```

Можно передавать индивидуальные аргументы, как у обычной функции:

```go
sum(1, 2)
// [1 2] -> 3
sum(1, 2, 3)
// [1 2 3] -> 6
```

А можно передать срез, преобразовав его в [список аргументов] с помощью `...`:

```go
nums := []int{1, 2, 3, 4}
sum(nums...)
// [1 2 3 4] -> 10
```


Нельзя декларировать функцию внутри другой функции. Это ограничение языка, связанное с особенностями компиляции.

Список возвращаемых значений имеет тот же синтаксис, что и список параметров. Например, можно написать коротко:

```go
func foo() (x, y, z int) 
```

Обратите внимание, что здесь возвращаемые значения имеют имена. В теле функции они могут использоваться как обычные переменные. При входе в функцию они будут инициализированы значениями по умолчанию для данного типа.

Если функция содержит именованные возвращаемые значения, то необязательно указывать список возвращаемых значений оператором `return`. В таком случае будут возвращены значения переменных, которые они имеют к этому моменту.

Если количество и тип возвращаемых функцией значений

```go
func foo()(int, int) 
```

в точности соответствуют параметрам другой функции,

```go
func bar(x int, y int) 
```

то допускается такой синтаксис вызова:

```go
bar(foo()) 
```

## Рекурсивные функции

В Go можно декларировать **рекурсивную функцию** — вызывающую саму себя.

Вот хрестоматийный пример рекурсивного вычисления `n!`, факториала числа:

```go
func fact(n int) int {
    if n == 0 {    // терминальная ветка — то есть условие выхода из рекурсии
        return 1
    } else {    // рекурсивная ветка 
        return n * fact(n-1)
    }
} 
```

А вот числа Фибоначчи:

```go
func Fib(n int) int {
    switch {
    case n <= 1:    // терминальная ветка 
        return n
    default:        // рекурсивная ветка
        return Fib(n-1) + Fib(n-2)
    }
} 
```

Всё как обычно.

Следует помнить, что в Go вызов функции имеет определённую вычислительную стоимость, а также затраты по памяти, ведь как минимум нужно скопировать аргументы. Поэтому множество вложенных вызовов функции может привести к снижению производительности программы и переполнению памяти.

Итеративные алгоритмы будут работать быстрее. Для сравнения приведём итеративную реализацию (на основе циклов) вышеуказанных примеров:

```go
func fact(n int) int {
    res := 1
    for n > 0 {
        res *= n
        n--
    }
    return res
} 
```

```go
func Fib(n int) int {
    a, b := 0, 1
    for n > 0 {
        a, b = b, a+b
        n--
    }
    return a
} 
```

Тем не менее это не означает, что рекурсивные алгоритмы неприменимы. В ряде случаев они могут быть полезнее, проще и делать код нагляднее.

Приведём пример работы с рекурсивным обходом всех файлов в данной директории, причём директория может содержать вложенные поддиректории:

```go

func main() {
    PrintAllFiles(".")
}

func PrintAllFiles(path string) {
    // получаем список всех элементов в папке (и файлов, и директорий)
    files, err := ioutil.ReadDir(path)
    if err != nil {
        fmt.Println("unable to get list of files", err)
        return
    }
    //  проходим по списку
    for _, f := range files {
        // получаем имя элемента
        // filepath.Join — функция, которая собирает путь к элементу с разделителями
        filename := filepath.Join(path, f.Name())
        // печатаем имя элемента
        fmt.Println(filename)
        // если элемент — директория, то вызываем для него рекурсивно ту же функцию
        if f.IsDir() {
            PrintAllFiles(filename)
        }
    }
} 
```

Итеративная реализация данного алгоритма была бы куда сложнее.

На основе функции `PrintAllFiles` из предыдущего примера реализуйте функцию `PrintAllFilesWithFilter(path string, filter string)`, которая будет печатать только путь со строкой `filter`.

``` go 
func main() {
PrintAllFilesWithFilter(".", "lesson")
PrintAllFilesWithFilter(".", "Functions")
}

func PrintAllFilesWithFilter(path string, filter string) {
    // получаем список всех элементов в папке (и файлов, и директорий)
    files, err := ioutil.ReadDir(path)
    if err != nil {
        fmt.Println("unable to get list of files", err)
        return
    }
    //  проходим по списку
    for _, f := range files {
        // получаем имя элемента
        // filepath.Join — функция, которая собирает путь к элементу с разделителями
        filename := filepath.Join(path, f.Name())
        // печатаем имя элемента, если путь к нему содержит filter
        if strings.Contains(filename, filter) {
            fmt.Println(filename)
        }
        // если элемент — директория, то вызываем для него рекурсивно ту же функцию
        if f.IsDir() {
            PrintAllFilesWithFilter(filename, filter)
        }
}
} 
```

## Функция первого класса

Функции в Go ничем не уступают другим классам объектов. У функции есть тип и значение. Функцию можно присвоить переменной, можно передать аргументом другой функции. Функция может возвращать в качестве значения другую функцию.

Тип функции виден в её сигнатуре, то есть определяется как набор типов и количества аргументов, возвращаемых значений.

Например, эта функция

```go
func Say(animal string) (v string) {
    switch animal {
    default:
        v = "heh"
    case "dog":
        v = "gav"
    case "cat":
        v = "myau"
    case "cow":
        v = "mu"
    }
    return
} 
```

имеет тип:

```go
func(string) string 
```

Можно присвоить её переменной такого типа:

```go
var voice func(string) string
voice = Say 
```

Можно написать функцию высшего порядка с параметром такого типа:

```go
func Print(who string, how func(string) string){
    fmt.Println(how(who))
} 
```

И передать ей функцию аргументом:

```go
Print("dog", Say) 
```

Для функции есть литеральная форма синтаксиса. Функцию можно создать по месту, не декларируя и не именуя в блоке деклараций.

```go
f := func(s string) string { return s } 
```

Можно даже использовать литерал в качестве аргумента при вызове:

```go
Print("dog", func(s string) string { return s }) 
```




[[Основы GO]] [[Анонимные функции]]