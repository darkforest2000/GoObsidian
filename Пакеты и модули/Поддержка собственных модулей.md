Весь код должен быть отформатирован стандартной утилитой [gofmt](https://golang.org/cmd/gofmt/) или её расширенной версией [goimports](https://pkg.go.dev/golang.org/x/tools/cmd/goimports). Утилита `goimports` делает то же самое, что и `gofmt`, но ещё автоматически оптимизирует и сортирует импорты.

## Документация и godoc

В экосистеме Go есть стандартная утилита для создания документации на основе комментариев в коде — это [godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc). Запустите `go install golang.org/x/tools/...@latest`, чтобы установить все пакеты и утилиты `golang.org/x/tools`, в том числе `godoc`.

Документация к любой сущности (функции, структуре, переменной или пакету) — это комментарий, который предшествует декларации этой сущности. Например:

```go
// Foo выполняет очень важную роль в проекте — ничего не делает :)
func Foo() {}

// описывает новый тип данных «никнейм» на основе стандартного строкового типа
type nickname string 
```

На основе таких комментариев `godoc` может сгенерировать документацию в формате HTML, `man pages` и т. д.

Документирование публичного API разрабатываемых пакетов позволяет сторонним разработчикам получить ответы на вопросы относительно функционала без чтения исходников. Документируйте свои пакеты — и жизнь пользователей станет лучше.

## Тестирование кода

Как известно, [код без тестов по определению сломан](https://www.slideshare.net/ericholscher/testing-slides-1387499/22-Code_without_tests_is_broken). Поэтому тестирование кода — обязательная часть разработки.

Подробный разбор тестирования запланирован в следующих уроках. Сейчас лишь подчеркнём, что пакетом с хорошим покрытием тестами пользоваться значительно приятнее, чем пакетом, в котором работоспособность кода зависит исключительно от внимательности автора.

## Версионирование без неожиданностей

В предыдущем уроке рассматривалась концепция семантического версионирования и говорилось о том, когда стоит менять версию пакета: патчевую, минорную или мажорную. Этих правил нужно придерживаться, особенно в случае поломки обратной совместимости. Ведь при разработке своего проекта никто не хочет внезапно узнать, что с сегодняшнего дня исчезла какая-нибудь функция, о существовании которой он и не подозревал, но из-за которой развалилась компиляция очень важной библиотеки.

Чтобы защититься от возмущений со стороны пользователей вашей библиотеки, не забывайте инкрементировать мажорную версию каждый раз, когда ломаете в библиотеке обратную совместимость.






[[Внешние зависимости]] [[Модули]] [[Пакеты и импорт]] 